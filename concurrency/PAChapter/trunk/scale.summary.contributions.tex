\subsection{Summary of contributions and overview}

In some sense, then, one could argue that -- given our long years of
experience with adding data structures to the $\lambda$-calculus -- it
merely remains to turn the handle to add common data structures and
reflection-based techniques to Milner's theory. In the case of data
structures, proposals like Fournet's applied $\pi$ \cite{} or Brown,
Laneve and Meredith's PiDuce \cite{}, can be seen in this light. Here
we offer an alternative. We are proposing a novel integration of data
structuring techniques and reflection-based meta-programming. It turns
out that substitution-based models of computation, which include
rewrite systems \cite{}, and especially nominal rewrite systems
\cite{} which include $\lambda$- and $\pi$-calculi, are amenable to
the application of a functor which generates a reflective theory. This
theory is then subject to a second functor that generates data
(de-)structuring techniques from the reflective apparatus.

We note that applied $\pi$ makes no commitment to a specific set of
data types, rather provides mechanism to enrich the ambient theory
with additional equational theories characterizing given data
types. The \texttt{PiDuce} proposal on the other hand follows industry
trends to make a commitment to a set of types that aligns with
\texttt{XML}. In the context of a discussion of coherence of data and
control both of these extremes raises the interesting question of
whether there are \emph{intrinsic} criteria for selecting a core set
of data types. This is where the reflective proposal differentiates
itself for in the reflective account the (data) structures necessary
to express processes become the basis of the core set of data
types. This automatically ensures a certain kind of coherence between
data and control calling to mind a refinement of the way
\texttt{S}-expressions reflect the means of expressing
\texttt{Lisp}-programs.

It should be stressed that we are not proposing that the calculus
immediately resulting from the application of the two functors
described in the previous paragraphs immediately scales to an
industrial strength concurrent language. In our view, this would only
be verified by concerted application to industrial scale problems and
the proposal is still too new for results of that kind to be
reported. Rather, by describing a mechanistic means of deriving the
computational model from Milner's theory, we are providing a means to
systematically explore the design space which -- when coupled with our
experience from functional programming -- seems a pragmatic approach
to the problem. Moreover, there are some promising features of the
proposal. One of these is a functorial mechanism for deriving both a
logic and a type system for the proposed calculus. These come directly
from Caires' work on behavioral and spatial logics and types
\cite{}. Apart from providing much needed support for mechanical
assistance in checking programm correctness and adherence to spec, we
take this as supporting evidence that the proposed means of exploring
the design space is not without merit.

We have used the word functor above because there is indeed a category
theoretic presentation of the results. However, we cannot
simultaneously present the derived calculus with sketch of its
applications and the category theoretic account without doubling the
length of this chapter. We settle on a more traditional syntactic and
operational account of the calculus (and how it is derived from
Milner's theory) and leave the category theoretic presentation for a
subsequent document. 

\subsubsection{Overview of chapter}

Apart from a brief digression into the history of the development of
semantics of functional languages the chapter follows the following
outline. First we review the core presentation of Milner's
$\pi$-calculus with careful attention to certain design choices that
impact the development of our derived calculus. Next we review the
derivation of a reflective version of that calculus. Then we derive
the data (de-)structuring techniques that turn the reflective
machinery into a data. Then we present some examples of coding in this
calculus. Penultimately, we illustrate the derivation of a logic and
it's application to one of the examples. Finally, we conclude with
some discussion of future directions for this work.

Now, in the interest of developing a little narrative tension, before
we dive into the presentation, we take a brief and highly
idiosyncratic digression through some of the history of the semantics
of functional languages.