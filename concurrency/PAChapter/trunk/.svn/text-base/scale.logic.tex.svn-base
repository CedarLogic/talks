\chapter{Logic}
\section{Namespace logic}
Namespace logic resides in the subfamily of Hennessy-Milner logics
discovered by Caires and Cardelli and known as spatial logics
\cite{DBLP:journals/tcs/CairesC04}. Thus, as is seen below, in
addition to the action modalities, we also find formulae for
\emph{separation}, corresponding, at the logical level, to the
structural content of the parallel operator at the level of the
calculus. Likewise, we have quantification over names. 

In this connection, however, we find an interesting difference between
spatial logics investigated heretofore and this one. As in the
calculus, we find no need for an operator corresponding to the $\nu$
construction. However, revelation in spatial logic, is a structural
notion \cite{DBLP:journals/tcs/CairesC04}. It detects the
\emph{declaration} of a new name. No such information is available in
the reflective calculus or in namespace logic. The calculus and the
logic can arrange that names are used in a manner consistent with
their being declared as new in the {\pic}, but it cannot detect the
declaration itself. Seen from this perspective, revelation is a
somewhat remarkable observation, as it seems to be about detecting the
programmer's intent.

\begin{figure}[hbp]
  \centering
  \Ovalbox{
    \begin{mathpar}
      \inferrule*[lab=Boolean] {} {{\phi, \psi} \bc \ptrue \;|\; \neg \phi \;|\; \phi \& \psi }
      \and
      \inferrule*[lab=Spatial] {} {\;|\; \pzero \;|\; \phi | \psi}
      \and
      \inferrule*[lab=Behavioral] {} {\;|\; \plift{a}{\phi} \;|\; \pprefix{a}{b}{\phi}}
      \and
      \inferrule*[lab=Recursive] {} {\;|\; \pgfp{X}{\phi}}
      \and \\
      \inferrule*[lab=Nominal] {} {\;|\; \pdropf{b} \;|\; \pquant{n}{\psi}{\phi}}
      \and  
      \inferrule*[] {} {{a} \bc \quotep{\phi} \;|\; b}
      \and
      \inferrule*[] {} {{b} \bc \quotep{P} \;|\; n}
    \end{mathpar}
  }
    \caption{ namespace logic formulae }
\end{figure}

We let $\PFormula$ denote the set of formulae generated by the
$\phi$-production, $\QFormula$ denote the set of formulae generated by
the $a$-production and $\PropVar$ denote the set of propositional
variables used in the $\textsf{rec}$ production.

% The satisfaction relation, $\models \subseteq \Proc \times \Formula$, between processes and formulae is given by

% \begin{eqnarray}
% 	P & \models & \ptrue \nonumber \\ 
%     P & \models & \pzero \riff P \scong \pzero \nonumber \\ 
%     P & \models & \neg \phi \riff P \not\models \phi \nonumber\\
%     P & \models & \phi \& \psi \riff P \models \phi \; \& P \; \models \psi \nonumber\\
%     P & \models & \binpar{\phi}{\psi} \riff \exists P_0, P_1.P \scong \binpar{P_0}{P_1}
%       \; \& \; P_0 \models \phi \; \& \;  P_1 \models \psi \nonumber\\
%     P & \models & \pdropf{b} \riff \exists Q, P'.P \scong \binpar{Q}{\dropn{x}}
% 	    \; \& \; x \models b \nonumber\\	
% 	P & \models & \plift{a}{\phi} \riff \exists Q, P'.P \scong \binpar{Q}{\lift{x}{P'}} 
% 		\; \& \; x \models a 
% 		\; \& \; P' \models \phi \nonumber\\
% 	P & \models & \pprefix{a}{b}{\phi} \riff \exists Q, P'.P \scong \binpar{Q}{\prefix{x}{y}{P'}} \nonumber\\
% 	  & & x \models a \nonumber\\
% 	  & & \forall c . \exists z . {P'}\substn{z}{y} \models {\phi}\substn{c}{b} \nonumber\\
%     \quotep{P} & \models & \quotep{\phi} \riff P \models \phi \nonumber\\
%     \quotep{P} & \models & \quotep{Q} \riff \quotep{P} \nameeq \quotep{Q} \nonumber
% \end{eqnarray}

Inspired by Caires' presentation of spatial logic
\cite{DBLP:conf/fossacs/Caires04}, we give the semantics in terms of
sets of processes (and names). We need the notion of a valuation $v :
\PropVar \to \wp(\Proc)$, and use the notation $v\substn{\mathcal{S}}{X}$ to mean 

\begin{eqnarray}
  v\substn{\mathcal{S}}{X}(Y) & = &
  \left\{ \begin{array}{ccc}
      S & & Y = X \\
      v(Y) & & otherwise \\
    \end{array}
  \right.\nonumber
\end{eqnarray}

The meaning of formulae is given in terms of two mutually recursive functions,

\begin{eqnarray}
\pmeaningof{ - }( - ) : \PFormula \times [\PropVar \to \wp(\Proc)] \to \wp(\Proc) \nonumber\\
\nmeaningof{ - }( - ) : \QFormula \times [\PropVar \to \wp(\Proc)] \to \wp(\QProc) \nonumber
\end{eqnarray}

taking a formula of the appropriate type and a valuation, and
returning a set of processes or a set of names, respectively.

\begin{figure}[hbp]
  \centering
  \Ovalbox{
    \begin{mathpar}
      \inferrule* [] {} {\pmeaningof{\ptrue}(v) = \Proc}
      \and \\
      \inferrule* [] {} {\pmeaningof{\neg \phi}(v) = \Proc \setminus \pmeaningof{\phi}(v)}
      \and
      \inferrule* [] {} {\pmeaningof{\phi \& \psi}(v) = \pmeaningof{\phi}(v) \cap \pmeaningof{\psi}(v)}
      \and \\  
      \inferrule* [] {} {\pmeaningof{\pzero}(v) = \{ P : P \scong \pzero \}}
      \and
      \inferrule* [] {} {\pmeaningof{\phi | \psi}(v) = \{ P : \exists P_0, P_1.P \scong P_0 | P_1, P_0 \in \pmeaningof{\phi}(v), P_1 \in \pmeaningof{\psi}(v) \}}
      \and
      \inferrule* [] {} {\pmeaningof{\plift{a}{\phi}}(v) = \{ P : \exists Q, P'.P \scong Q |\lift{x}{P'}, \; x \in \nmeaningof{a}(v),\; P' \in \pmeaningof{\phi}(v) \}}
      \and
      \inferrule* [] {} {\pmeaningof{\pprefix{a}{b}{\phi}}(v) = \{ P : \exists Q, P'.P \scong Q | x(y).P', x \in \nmeaningof{a}(v), \\\\ \;\;\;\;\;\;\;\;\;\; \forall c . \exists z . {P'}\substn{z}{y} \in \pmeaningof{{\phi}\substn{c}{b}}(v) \}}
      \and
      \inferrule* [] {} {\pmeaningof{\pgfp{X}{\phi}}(v) = \cup \{ \mathcal{S} \subseteq \Proc : \mathcal{S} \subseteq \pmeaningof{\phi}(v\substn{\mathcal{S}}{X})\}}
      \and
      \inferrule* [] {} {\pmeaningof{\pdropf{b}}(v) = \{ P : \exists Q, P'.P \scong Q | \dropn{x}, \; x \in \nmeaningof{b}(v) \}}
      \and
      \inferrule* [] {} {\pmeaningof{\pquant{n}{\psi}{\phi}}(v) = \cap_{x \in \nmeaningof{\quotep{\psi}}(v)} \pmeaningof{{\phi}\substn{x}{n}}(v)}
      \and
      \inferrule* [] {} {\nmeaningof{\quotep{\phi}}(v) = \{ x : x \nameeq \quotep{P}, P \in \pmeaningof{\phi}(v) \}}
      \and
      \inferrule* [] {} {\nmeaningof{\quotep{P}}(v) = \{ x : x \nameeq  \quotep{P} \}}
    \end{mathpar}
  }
  \caption{ namespace logic semantics }
\end{figure}

We say $P$ witnesses $\phi$ (resp., $x$ witnesses $\quotep{\phi}$),
written $P \models \phi$ (resp., $x \models \quotep{\phi}$) just when
$\forall v . P \in \meaningof{\phi}(v)$ (resp., $\forall v . x \in \meaningof{\quotep{\phi}}(v)$).

\begin{theorem}[Equivalence]
	$P \wbbisim Q \riff \forall \phi . P \models \phi \riff Q \models \phi .$
\end{theorem}

The proof employs an adaptation of the standard strategy. As noted in
the introduction, this theorem means that there is no algorithm
guaranteeing that a check for the witness relation will terminate.

\subsubsection{Syntactic sugar }

In the examples below, we freely employ the usual DeMorgan-based
syntactic sugar. For example,

\begin{eqnarray}
	\phi \Rightarrow \psi & \triangleq & \neg ( \phi \& \neg \psi ) \nonumber\\
	\phi \vee \psi & \triangleq & \neg ( \neg \phi \& \neg \psi ) \nonumber
\end{eqnarray}

Also, when quantification ranges over all of $\Proc$, as in
$\pquant{n}{\quotep{\ptrue}}{\phi}$, we omit the typing for the
quantification variable, writing $\pquantuntyped{n}{\phi}$.

\subsection{Examples}

\subsubsection{Controlling access to namespaces}

Suppose that $\quotep{\phi}$ describes some namespace, i.e. some
collection of names. We can insist that a process restrict its next
input to names in that namespace by insisting that it witness the formula

\begin{eqnarray}
  \pprefix{\quotep{\phi}}{b}{\ptrue} \& \neg \pprefix{\quotep{\neg \phi}}{b}{\ptrue} \nonumber
\end{eqnarray}

which simply says the the process is currently able to take input from
a name in the namespace $\quotep{\phi}$ and is not capable of input on
any name not in that namespace. In a similar manner, we can limit a
server to serving only inputs in $\quotep{\phi}$ throughout the
lifetime of its behavior \footnote{Of course, this formula also says
  the server never goes down, either -- or at least is always willing
  to take such input...;-)}

\begin{eqnarray}
  \pgfp{X}{\pprefix{\quotep{\phi}}{b}{X} \& \neg \pprefix{\quotep{\neg \phi}}{b}{\ptrue}} \nonumber
\end{eqnarray} 

This formula is reminiscent of the functionality of a firewall, except
that it is a \emph{static} check. A process witnessing this formula
will behave as though it were behind a firewall admitting only access
to the ports in $\quotep{\phi}$ without the need for the additional
overhead of the watchdog machinery.

\subsubsection{Validating the structure of data}

Of course, the previous example might make one wonder what a useful
namespace looks like. The relevance of this question is further
amplified when we observe that processes pass names as messages as
well as use them to govern synchronization. The next example,
therefore, considers a space of names that might be seen as
well-suited to play the role of data, for their structure loosely
mimics the structure of the infoset model \cite{W3CInfoset} of
\texttt{XML} (sans schema).

\begin{eqnarray}
  \phi_{info} & = &
  \quotep{\pgfp{X}
    {(\pquantuntyped{m}
      {\plift
        {m}
        {\pquantuntyped
          {n}
          {\pzero
            \vee \plift{n}{X}
            \vee \pgfp{Y}{(\pquantuntyped{n'}{\pprefix{n'}{b}{(X \vee Y)}})}
            \vee (\binpar{X}{X})
          }}})}}\nonumber
\end{eqnarray} 

The formula is essentially a recursive disjunction selecting names
that are first of all rooted with an enclosing lift operation --
reminiscent of the way an \texttt{XML} document has a single enclosing
root; and then are either

\begin{itemize}
\item the empty `document'; or
\item an `element'; or
\item a sequence of documents each `located' at an input action; or
\item an unordered group.
\end{itemize}

Notice that it is possible to parameterize this namespace on names for
rooting `documents' or `elements'. Currently, these are typed as
coming from the whole namespace, ${\quotep{\ptrue}}$, but they could
come from any subspace.

Moreover, the formula is itself a template for the interpretation of
schema specifications \cite{W3CXSD}. If we boil \texttt{XSD} schema
down to its essential type constructors, we have a recursive
specification in which a schema is a

\begin{itemize}
\item a sequence, or
\item a choice, or
\item a group, or
\item a recursion, in which a type name is bound to a schema definition
\end{itemize}

of element-tagged schema or schema references, with the recursive
specification bottoming out at the simple and builtin
types. Abstractly, then essential structures of \texttt{XSD} schema
are captured by the grammar

\begin{figure}[hbp]
  \centering
  \Ovalbox{
    \begin{mathpar}
      \inferrule* [] {} {{S} \bc ESeq \;|\; ESum \;|\; EGrp \;|\; \pgfp{N}{S} }
      \and \\
      \inferrule* [] {} {{ESeq} \bc \epsilon \;|\; E,ESeq}
      \and
      \inferrule* [] {} {{ESum} \bc \epsilon \;|\; E+ESum}
      \and
      \inferrule* [] {} {{EGrp} \bc \epsilon \;|\; E | EGrp}
      \and \\
      \inferrule* [] {} {{E} \bc tag(N \mid S)}
    \end{mathpar}
  }
  \caption{ \texttt{XML}-like schema }
\end{figure}

We use $s$ to range over schema, $\sigma$, $\chi$ and $\gamma$ to
range over sequences, choices and groups, respectively.

The encoding below, which for clarity makes liberal -- but obvious --
use of polymorphism and elides the standard machinery for
treating recursion variables, illustrates that we can view this
grammar as essentially providing a high-level language for carving out
namespaces in which the names conform to the schema.

\begin{eqnarray}
  \meaningof{\epsilon} & = & \quotep{\pzero} \nonumber\\
  \meaningof{tag(s), \sigma}
  & = & \quotep{\pquant{n}{\meaningof{tag}}{\pprefix{n}{b}{(\binpar{\meaningof{s}}{\meaningof{\sigma}})}}} \nonumber\\
  \meaningof{tag(s) + \chi}
  & = & \quotep{\pquant{n}{\meaningof{tag}}{(\pprefix{n}{b}{\meaningof{s}}) \vee \meaningof{\chi}}} \nonumber\\
  \meaningof{tag(s) \mid \gamma}
  & = & \quotep{\pquant{n}{\meaningof{tag}}{(\pprefix{n}{b}{\meaningof{s}}) | \meaningof{\gamma}}} \nonumber\\
\meaningof{\pgfp{N}{s}}
  & = & \quotep{\pgfp{N}{\meaningof{s}}} \nonumber
\end{eqnarray}

We emphasize that the example is not meant to be a complete account of
\texttt{XML} schema. Rather, it is intended to suggest that with the
reflective capabilities the logic gives a fairly intuitive treatment
of names as structured data. The simplicity and intuitiveness of the
treatment is really brought home, however, when employing the
framework analytically. As an example, from a commonsense perspective
it should be the case that any \texttt{XML} document that observes a schema
automatically also corresponds to an infoset. The reader is encouraged
to try her hand at using the framework to establish that if $s$ is a
schema, then

\begin{eqnarray}
  x \models \meaningof{s} \Rightarrow x \models \phi_{info}' \nonumber
\end{eqnarray}

where $\phi_{info}'$ a suitably modified version of $\phi_{info}$.