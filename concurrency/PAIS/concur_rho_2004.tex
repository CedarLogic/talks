% ------------------------------------------------------------------------
% AMS-LaTeX Paper ********************************************************
% ------------------------------------------------------------------------
% Submitted:      Dec 15 2003
% Final Version:  
% Accepted:       
% ------------------------------------------------------------------------
% This is a journal top-matter template file for use with AMS-LaTeX.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\documentclass{tran-l}
%\documentclass[twocolumn]{amsart}
\documentclass[]{amsart}
%\documentclass[]{llncs}

%\usepackage[active]{srcltx} % SRC Specials for DVI Searching
\usepackage{url}

% From Allen's stable.
\usepackage{bigpage}
\usepackage{bcprules}
\usepackage{code}
\usepackage{amsfonts}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{caption}
\usepackage{multicol}

% Double brackets
\newcommand{\ldb}{[\![}
\newcommand{\rdb}{]\!]}
\newcommand{\lliftb}{\langle\!|}
\newcommand{\rliftb}{|\!\rangle}
% \newcommand{\lpquote}{\langle}
% \newcommand{\rpquote}{\rangle}
% \newcommand{\lpquote}{\lceil}
% \newcommand{\rpquote}{\rceil}
\newcommand{\lpquote}{\ulcorner}
\newcommand{\rpquote}{\urcorner}
\newcommand{\newkw}{\nu}

% SYNTAX
\newcommand{\id}[1]{\texttt{#1}}
\newcommand{\none}{\emptyset}
\newcommand{\eps}{\epsilon}
\newcommand{\set}[1]{\{#1\}}
\newcommand{\rep}[2]{\id{\{$#1$,$#2$\}}}
\newcommand{\elt}[2]{\id{$#1$[$#2$]}}
\newcommand{\infinity}{$\infty$}

\newcommand{\pzero}{\mathbin{0}}
\newcommand{\seq}{\mathbin{\id{,}}}
\newcommand{\all}{\mathbin{\id{\&}}}
\newcommand{\choice}{\mathbin{\id{|}}}
\newcommand{\altern}{\mathbin{\id{+}}}
\newcommand{\juxtap}{\mathbin{\id{|}}}
\newcommand{\concat}{\mathbin{\id{.}}}
\newcommand{\punify}{\mathbin{\id{:=:}}}
\newcommand{\fuse}{\mathbin{\id{=}}}
\newcommand{\scong}{\mathbin{\equiv}}
\newcommand{\nameeq}{\mathbin{\equiv_N}}
\newcommand{\alphaeq}{\mathbin{\equiv_{\alpha}}}
\newcommand{\freenames}[1]{\mathbin{\mathcal{FN}(#1)}}
\newcommand{\boundnames}[1]{\mathbin{\mathcal{BN}(#1)}}
%\newcommand{\lift}[2]{\texttt{lift} \; #1 \concat #2}
\newcommand{\binpar}[2]{#1 \juxtap #2}
\newcommand{\outputp}[2]{#1 \id{[} #2 \id{]}}
\newcommand{\prefix}[3]{#1 \id{(} #2 \id{)} \concat #3}
\newcommand{\lift}[2]{#1 \lliftb #2 \rliftb}
\newcommand{\quotep}[1]{\lpquote #1 \rpquote}
\newcommand{\dropn}[1]{\rpquote #1 \lpquote}

\newcommand{\newp}[2]{\id{(}\newkw \; #1 \id{)} #2}
\newcommand{\bangp}[1]{\id{!} #1}

\newcommand{\substp}[2]{\id{\{} \quotep{#1} / \quotep{#2} \id{\}}}
\newcommand{\substn}[2]{\id{\{} #1 / #2 \id{\}}}

\newcommand{\psubstp}[2]{\dropn{\substp{#1}{#2}}}
\newcommand{\psubstn}[2]{\dropn{\substn{#1}{#2}}}

\newcommand{\applyp}[2]{#1 \langle #2 \rangle}
\newcommand{\absp}[2]{\id{(} #1 \id{)} #2}

\newcommand{\transitions}[3]{\mathbin{#1 \stackrel{#2}{\longrightarrow} #3}}
\newcommand{\meaningof}[1]{\ldb #1 \rdb}

\newcommand{\Proc}{\mathbin{Proc}}
\newcommand{\QProc}{\quotep{\mathbin{Proc}}}

\newcommand{\entailm}{\mathbin{\vdash_{\mathfrak m}}} %matching
\newcommand{\entailp}{\mathbin{\vdash_{\mathfrak p}}} %behavioral
\newcommand{\entailv}{\mathbin{\vdash_{\mathfrak v}}} %validation
\newcommand{\congd}{\mathbin{\equiv_{\mathfrak d}}}
\newcommand{\congs}{\mathbin{\equiv_{\mathfrak s}}}
\newcommand{\congp}{\mathbin{\equiv_{\mathfrak p}}}
%\newcommand{\logequiv}{\mathbin{\leftrightarrow}}

\newcommand{\barb}[2]{\mathbin{#1 \downarrow_{#2}}}
\newcommand{\dbarb}[2]{\mathbin{#1 \Downarrow_{#2}}}

% From pi-duce paper
\newcommand{\red}{\rightarrow}
\newcommand{\wred}{\Rightarrow}
\newcommand{\redhat}{\hat{\longrightarrow}}
\newcommand{\lred}[1]{\stackrel{#1}{\longrightarrow}} %transitions
\newcommand{\wlred}[1]{\stackrel{#1}{\Longrightarrow}}

\newcommand{\opm}[2]{\overline{#1} [ #2 ]} % monadic
\newcommand{\ipm}[2]{{#1} ( #2 )} 
\newcommand{\ipmv}[2]{{#1} ( #2 )} % monadic
\newcommand{\parop}{\;|\;}		% parallel operator
\newcommand{\patmatch}[3]{#2 \in #3 \Rightarrow #1}
\newcommand{\sdot}{\, . \,}		% Space around '.'
\newcommand{\bang}{!\,}
%\newcommand{\fuse}[1]{\langle #1 \rangle}		
\newcommand{\fusion}[2]{#1 = #2} % fusion prefix/action
\newcommand{\rec}[2]{\mbox{\textsf{rec}} \, #1. \, #2}
\newcommand{\match}[2]{\mbox{\textsf{match}} \; #1 \; \mbox{\textsf{with}} \; #2}
\newcommand{\sep}{:}
\newcommand{\val}[2]{\mbox{\textsf{val}} \; #1 \; \mbox{\textsf{as}} \; #2}

\newcommand{\rel}[1]{\;{\mathcal #1}\;} %relation
\newcommand{\bisim}{\stackrel{.}{\sim}_b} %bisimilar
\newcommand{\wb}{\approx_b} %weak bisimilar
\newcommand{\bbisim}{\stackrel{\centerdot}{\sim}} %barbed bisimilar
\newcommand{\wbbisim}{\stackrel{\centerdot}{\approx}} %weak barbed bisimilar
\newcommand{\bxless}{\lesssim}	%expansion less (amssymb required)
\newcommand{\bxgtr}{\gtrsim}	%expansion greater (amssymb required)
\newcommand{\beq}{\sim}		%barbed congruent
\newcommand{\fwbeq}{\stackrel{\circ}{\approx}}	%weak barbed congruent
\newcommand{\wbeq}{\approx}	%weak barbed congruent
\newcommand{\sheq}{\simeq}	%symbolic hypereq
\newcommand{\wbc}{\approx_{cb}}

% End piduce contribution

\newcommand{\typedby}{\mathbin{\:\colon}}
\newcommand{\mixedgroup}[1]{\id{mixed($#1$)}}
\newcommand{\cast}[2]{\id{CAST AS} \; #1 \; (#2)}
\newcommand{\bslsh}{\mathbin{\id{\\}}}
\newcommand{\bslshslsh}{\mathbin{\id{\\\\}}}
\newcommand{\fslsh}{\mathbin{\id{/}}}
\newcommand{\fslshslsh}{\mathbin{\id{//}}}
\newcommand{\bb}[1]{\mbox{#1}}
\newcommand{\bc}{\mathbin{\mathbf{::=}}}
\newcommand{\bm}{\mathbin{\mathbf\mid}}
\newcommand{\be}{\mathbin{=}}
\newcommand{\bd}{\mathbin{\buildrel {\rm \scriptscriptstyle def} \over \be}}
\newcommand{\category}[1]{\mbox{\bf #1}}

%GRAMMAR
\newlength{\ltext}
\newlength{\lmath}
\newlength{\cmath}
\newlength{\rmath}
\newlength{\rtext}

\settowidth{\ltext}{complex type name}
\settowidth{\lmath}{$xxx$}
\settowidth{\cmath}{$::=$}
\settowidth{\rmath}{\id{attributeGroup}}
\settowidth{\rtext}{repetition of $g$ between $m$ and $n$ times}

\newenvironment{grammar}{
  \[
  \begin{array}{l@{\quad}rcl@{\quad}l}
  \hspace{\ltext} & \hspace{\lmath} & \hspace{\cmath} & \hspace{\rmath} & \hspace{\rtext} \\
}{
  \end{array}\]
}

% Over-full v-boxes on even pages are due to the \v{c} in author's name
\vfuzz2pt % Don't report over-full v-boxes if over-edge is small

% THEOREM Environments ---------------------------------------------------
 \newtheorem{thm}{Theorem}[subsection]
 \newtheorem{cor}[thm]{Corollary}
 \newtheorem{lem}[thm]{Lemma}
 \newtheorem{prop}[thm]{Proposition}
 \theoremstyle{definition}
 \newtheorem{defn}[thm]{Definition}
 \theoremstyle{remark}
 \newtheorem{rem}[thm]{Remark}
 \newtheorem{example}[thm]{Example}
 \numberwithin{equation}{subsection}
% MATH -------------------------------------------------------------------
 \DeclareMathOperator{\RE}{Re}
 \DeclareMathOperator{\IM}{Im}
 \DeclareMathOperator{\ess}{ess}
 \newcommand{\veps}{\varepsilon}
 \newcommand{\To}{\longrightarrow}
 \newcommand{\h}{\mathcal{H}}
 \newcommand{\s}{\mathcal{S}}
 \newcommand{\A}{\mathcal{A}}
 \newcommand{\J}{\mathcal{J}}
 \newcommand{\M}{\mathcal{M}}
 \newcommand{\W}{\mathcal{W}}
 \newcommand{\X}{\mathcal{X}}
 \newcommand{\BOP}{\mathbf{B}}
 \newcommand{\BH}{\mathbf{B}(\mathcal{H})}
 \newcommand{\KH}{\mathcal{K}(\mathcal{H})}
 \newcommand{\Real}{\mathbb{R}}
 \newcommand{\Complex}{\mathbb{C}}
 \newcommand{\Field}{\mathbb{F}}
 \newcommand{\RPlus}{\Real^{+}}
 \newcommand{\Polar}{\mathcal{P}_{\s}}
 \newcommand{\Poly}{\mathcal{P}(E)}
 \newcommand{\EssD}{\mathcal{D}}
 \newcommand{\Lom}{\mathcal{L}}
 \newcommand{\States}{\mathcal{T}}
 \newcommand{\abs}[1]{\left\vert#1\right\vert}
% \newcommand{\set}[1]{\left\{#1\right\}}
%\newcommand{\seq}[1]{\left<#1\right>}
 \newcommand{\norm}[1]{\left\Vert#1\right\Vert}
 \newcommand{\essnorm}[1]{\norm{#1}_{\ess}}

%%% NAMES
\newcommand{\Names}{{\mathcal N}}
\newcommand{\Channels}{{\sf X}}
\newcommand{\Variables}{{\mathcal V}}
\newcommand{\Enames}{{\mathcal E}}
\newcommand{\Nonterminals}{{\mathcal S}}
\newcommand{\Pnames}{{\mathcal P}}
\newcommand{\Dnames}{{\mathcal D}}
\newcommand{\Types}{{\mathcal T}}

\newcommand{\fcalc}{fusion calculus}
\newcommand{\xcalc}{${\mathfrak x}$-calculus}
\newcommand{\lcalc}{$\lambda$-calculus}
\newcommand{\pic}{$\pi$-calculus}
\newcommand{\rhoc}{$\rho$-calculus}
\newcommand{\hcalc}{highwire calculus}
\newcommand{\dcalc}{data calculus}
%XML should be all caps, not small caps. --cb
%\newcommand{\xml}{\textsc{xml}}
\newcommand{\xml}{XML} 

\newcommand{\papertitle}{New, on reflection}
% use static date to preserve date of actual publication
 \newcommand{\paperversion}{Draft Version 0.1 - December 30, 2003}

\newenvironment{toc}
{
\begin{list}{}{
   \setlength{\leftmargin}{0.4in}
   \setlength{\rightmargin}{0.6in}
   \setlength{\parskip}{0pt}
 } \item }
{\end{list}}

\newenvironment{narrow}
{
\begin{list}{}{
   \setlength{\leftmargin}{0.4in}
   \setlength{\rightmargin}{0.6in}
 } \item }
{\end{list}}

%%% ----------------------------------------------------------------------
\begin{document}

%These margin values appear to be relative to the bigpage package settings. --cb
\setlength{\topmargin}{0in}
\setlength{\textheight}{8.5in}
\setlength{\parskip}{6pt}

\title{\huge{\papertitle}}

\author{ L.G. Meredith }

\author{ Allen L. Brown, Jr. }

\author{ David Richter }

%\address{Microsoft Corporation, Redmond, Washington, USA}

%\email{gregmer@microsoft.com}

%\thanks{This work was completed under the BigTop project.}

%\subjclass{Primary 47A15; Secondary 46A32, 47D20}

\keywords{concurrency, distribution, message-passing, process calculus, service-oriented architecture, quality of service, service level agreement}

%\date{April 6, 2002.}

\dedicatory{}

%\commby{Daniel J. Rudolph}

%%% ----------------------------------------------------------------------

\begin{abstract}
\normalsize{ 

Many of the features one might consider for a practical programming
language based on mobile process algebras
\cite{MilnerPi}\cite{SangiorgiWalker} including implementation
strategies for recursion; sending and receiving complex data; macros;
and durability across transactions can all be related to
\textit{serialization}, in the sense of producing an external
representation of a process. Towards a theory which accounts for these
phenomena, internally, we study a construction for adding reflection
to name-passing calculi.

We illustrate the construction by applying it to the pure asynchronous
{\pic}, to arrive at a variant we dub the {\rhoc}. The calculus is
Turing-complete and yet is free of any explicit construct for
recursion or replication. Moreover, it endures no explicit operator
for the construction and binding of fresh names. Instead, the
reflective mechanism it introduces, allowing for turning processes
into names and names into processes, suffices to recapitulate all of
the functionality normally found in non-reflective process algebras.
We also consider some examples that suggest it is a promising start to
treating the phenomena mentioned afore.

}

\end{abstract}

\noindent
{\large \textbf{
Concur submission draft}}\\
\rule{6.25in}{0.75pt}\\\\\\

%%% ----------------------------------------------------------------------
\maketitle
%%% ----------------------------------------------------------------------

% \begin{center}
% \paperversion\\
% \end{center}

% \begin{toc}
% \tableofcontents
% \end{toc}

% \newpage
% ------------------------------------------------------------------------

\section{Introduction}

Many of the features one might consider for a practical programming
language based on mobile process algebras
\cite{MilnerPi}\cite{SangiorgiWalker} including implementation
strategies for recursion; sending and receiving complex data; macros;
and durability across transactions can all be related to
\textit{serialization}, in the sense of producing an external
representation of a process. For example, one of the key points of
transaction semantics in systems like \texttt{Biztalk} \cite{biztalk}
is \textit{durability}. A running process restarts from the last known
transacted outcome in the event of failure and restart. Such
durability requires (upon entering a transacted context) the ability
to serialize a representation of the state of the process and commit
it to durable store, like a database management system. It also
requires being able to deserialize that representation into an
executing process on restart.
 
Another example comes in the form of macros. A sophisticated macro
capability, such as one sees in implementations of the language
\texttt{Scheme} \cite{r5rs}, works by being able to turn program
source into data, operate on the data, and turn the modified data back
into program source. What unifies these two examples, in the mobile
process algebra setting, is that program source may be identified with
program state in the sense that there is no hidden virtual machine
state that also needs to be captured. Thus, having a solution to one
means, effectively, having a solution for the other.

These two features are also distinguished from each other by a certain
characteristic. In the case of recovery, program state may very well
be inspected by the recovering program to make decisions regarding
what branch to execute. That is, application level logic makes use of
reified process state. Even in the most sophisticated a macro systems,
on the other hand, the program logic is insulated from the
macro-expansion process. But, it is still the case, in the
sophisticated macro system, that the programming language in which
macros are expressed is the language in which program source is
expressed. In this sense, macros are 'meta-programs', or programs that
calculate programs, while the durability feature of systems like
\texttt{Biztalk} make some application programs also be meta-programs.
 
By way of introducing a nomenclature for discussing the results of the
paper, we observe that-- although the usage is a bit stretched-- in
common parlance, a structured way of turning program into data and
data into program has been dubbed \textit{reflection}. In point of
fact, there are several forms of reflection that may be distinguished
from one another: structural, procedural and lexical.

Structural reflection is best exemplified in a language like
\texttt{Java} \cite{JavaReflection}. Program elements, e.g. classes,
may be turned into program manipulable data structures. But, it is not
the case that the state of a virtual machine executing a \texttt{Java}
program is manipulable by a program running in that virtual
machine. This is to be contrasted with procedurally reflective
languages like \texttt{3-Lisp} \cite{lisp3} and \texttt{Rosette}
\cite{rosette} where the state of the executing machinery is also made
available as program-manipulable data.

In lexical reflection, every element of the \textit{syntax} of the
language has a representation as a manipulable program data
structure. This is not the case in languages like \texttt{Java}. But,
it is found in \texttt{Rosette} and \texttt{3-Lisp}. Note that while
this is not generally recognized under this term in the literature,
the phenomenon is real. Among other things, this feature forms the
basis of an architecture for parser generation.

The approach to name-passing calculi that we study here effectively
allows a treatment of all three types of reflection within the theory.

In a similar vein, it is really beyond human capability to do
significant calculation with the {\pic} as it stands. Without the
ability to send and receive complex data, calculation quickly becomes
incomprehensible. One needs a higher level abstraction, for example,
to carry out any sort of ordinary arithmetic. Providing a higher level
language for data manipulation begs the question: how does the data
language relate to the control language? Why isn't there only one
language? Adding reflection to name-passing calculi suggests it may be
possible to achieve a unification by making the program constructors
of the language \textit{be} the data constructors. Of course, it
doesn't specify which process constructors represent the data
abstractions.

Surprisingly, it also has consequences for practical issues of space
management and the implementation of recursive features, like
$!P$. For example, if the $(\nu \; x)-$ operator is interpreted as an
operation involving memory allocation then there is a problem
satisfying the structural equivalence

\begin{equation*}
	(\nu \; x)(\nu \; x)P \scong (\nu \; x)P
\end{equation*}

The left hand side may cause a memory fault while the right hand side
does not. If, on the other hand, the operator is not interpreted as an
operation involving memory allocation, then what is the
interpretation? In point of fact, it says that the $\nu$-binder must
be \textit{lazily} related to memory allocation. Considering these
implementation strategies is at level of detail too rich for
name-passing process algebras presented to date.

Lucian Wischik was motivated by this problem (and others) with the
implementation of the $(\nu \; x)-$ operator to develop the \textit{global
{\pic}} \cite{globalpi}. We were very much surprised to see how similar our
behavioral rules were to his when we developed this calculus. Of
course, there is a difference. The difference is that we say exactly
which set of names are the global names and provide a rationale for
picking this set: the names are the reified processes.

Another point that bears mentioning is the treatment of recursive
constructs, like $!P$. In most practical implementations this is
achieved by making program source (at some level of representation)
multiply instantiable. The mobile process algebras provide only a
specification of this behavior (in the form of the structural
congruence rules for $!P$, or in some presentations, in the
dynamics). They steadfastly remain silent on implementation
strategies, and rightly so. 

One thing is clear, the approach leads to a theory enjoying
sufficiently rich detail to describe implementation strategies for
this specification. In some sense, the situation is analogous to the
difference between the $\lambda$-calculus and the {\pic}. The latter
is a theory with a richer, or more intensional structure, allowing a
finer grain of distinctions to be made. Likewise, the calculus at
which we arrive is a calculus that allows a more intensional
characterization of the features the name-passing calculi take for
granted.

In this paper we illustrate the construction for a pure asynchronous
calculus. But, we stress that this construction works for name-passing
calculi, in general. 

%%% ----------------------------------------------------------------------

\section{The calculus}

To motivate the technical presentation we wish to make an observation
about the asynchronous {\pic}: it is a theory parametric in a theory
of \textit{names}. Standard presentations assume a supply of names and
a theory of equality on them. This point is made abundantly clear in
such presentations by the grammar describing terms of the language:
there is no production for names. Names are taken to be terminals in
the grammar. \footnote{ \texttt{Biztalk} takes advantage of this fact
in its binding language. A binding says what kind of terminal a name
is, e.g. a object reference, or an \texttt{MSMQ} queue.}

\subsubsection{Quote}
We will adopt a different tac by closing the theory processes, making
processes serve as their own theory of names. So, the first point of
departure from a standard presentation of the asynchronous
{\pic} is a production for names in the grammar. A name will
be a \textit{quoted} process, $\quotep{P}$. 

\subsubsection{Lift}
Note that name construction is not process construction. So, if one
wants to be able to generate a name from a given process, there must
be an operator in the term language that creates a name from a
process. This is the motivation for the production $\lift{x}{P}$,
dubbed here the \emph{lift} operator.

In terms of the nomenclature above, that this mechanism allows (for
one half of) both structural reflection should be clear: program
elements are being turned into data. As we shall see, though, it is
also possible to saturate processes with the lift
operator. Intuitively, this means that every continuation is reified
before evaluation. This mechanism forms the basis of procedural
reflection.

\subsubsection{Dropping $\nu$}
The lift operator turns out to play a role analogous to $(\nu \;
x)P$. It is certainly a mechanism by which processes may manufacture
fresh occurrences of names. As such, it turns out not to be necessary
to provide the $\nu$-binder. We will illustrate the implementation of
$\nu$ in the sequel.

\begin{rem}
On the basis of responses to talks about this material, at this point
we issue a warning to the reader: it will turn out that quoted
processes are opaque to substitutions. But, this operator is not. This
will provide a key difference between $\lift{x}{P}$ and outputing a
quoted process.
\end{rem}

\subsubsection{Eval}
Of course, if a name is a quoted process, it would be very handy to
have a way of \textit{evaluating} such an entity. Thus, one of term
constructors for processes takes a name, say $x$, and extracts the
process from it, $\dropn{x}$. This operator, nicknamed \emph{drop} to
parallel lift, is the other half of the reflective mechanism; it
allows data to be transformed back into program.

\subsubsection{Dropping replication}
It is well-known that replication is not required in a higher-order
process algebra \cite{SangiorgiWalker}. While our algebra is
\textit{not} higher-order in the traditional sense (there are not
formal process variables of a different type from names) it has all
the features of a higher-order process algebra. Thus, it turns out
that there is no need for a term for recursion. To illustrate this we
present an implementation of $!P$ in this calculus. Intuitively, this
will amount to receiving a quoted form of a process, evaluating it,
while making the quoted form available again.

\subsubsection{Name equality}
In standard presentations of the asynchronous {\pic}, the
statement of the communications rule critically depends on the
equality that comes with the theory of names. The situation is the
same here. For output and input processes to communicate it is
important to know how to determine whether the subject guards are the
same. But, another interesting point of departure between the calculi
is reflected in the fact that in the former, the theory of equality of
names is opaque. It must be give a priori, and this determination is
deemed independent of the theory of processes. In the latter, the
equality between names is not opaque, but given explicitly, and is
determined by the structure of processes. More about this point later,
though.

\subsubsection{Notation}

We distinguish between syntactic categories and elements
thereof. Thus, $\category{P}$ denotes a syntactic category, while $P$
is an element of that category.

\begin{grammar}
\mbox{\rhoc}		& \category{P}			& \bc	& \pzero \\
				&					& \bm	& \category{x}\id{[}\category{x}\id{]} \\
				&					& \bm	& \category{x}\id{(}\category{x}\id{)} \concat \category{P} \\
				&					& \bm	& \lift{\category{x}}{\category{P}} \\
				&					& \bm	& \category{P} \juxtap \category{P} \\
				&					& \bm	& \dropn{\category{x}} \\
				& \category{x}  		& \bc	& \quotep{\category{P}}
\end{grammar}

\subsection{Free and bound names}

The syntax has been carefully chosen so that a bindging occurrence of
a name is sandwiched between round braces. Thus, the calculation of
the free names of a process, $P$, denoted $\freenames{P}$ is given
recursively by

%\begin{multicols}{2}
%{
	\begin{eqnarray*}
		\freenames{\pzero} & = & \emptyset \\
		\freenames{x \id{[}y\id{]}} & = & \{ x, y \} \\
		\freenames{x \id{(}y\id{)} \concat P} & = & \{ x \} \cup (\freenames{P} \setminus \{ y \}) \\
		\freenames{\lift{x}{P}} & = & \{ x \} \cup \freenames{P} \\
		\freenames{\binpar{P}{Q}} & = & \freenames{P} \cup \freenames{Q} \\
		\freenames{\dropn{x}} & = & \{ x \} \\
	\end{eqnarray*}
%}
%\end{multicols}

\subsection{Structural congruence}

The {\em structural congruence} of processes, noted $\scong$, is the
least congruence, containing $\alphaeq$ that satisfies the following
laws:

\begin{eqnarray*}
	\category{P} \juxtap \pzero	
		&  \scong \; \category{P} \; \scong & 
			\pzero \juxtap \category{P} \\
	\category{P}_0 \juxtap \category{P}_1	
		& \scong & 
			\category{P}_1 \juxtap \category{P}_0 \\
	(\category{P}_0 \juxtap \category{P}_1) \juxtap \category{P}_2	
		& \scong & 
			\category{P}_0 \juxtap (\category{P}_1 \juxtap \category{P}_2) \\
\end{eqnarray*}

\subsection{Name equivalence}

we must first equip our names with a theory of equality. We take this
to be the smallest equivalence relation generated by the following
rules.

\infrule[Quote-drop]
{  }
{ \quotep{\dropn{x}} \nameeq x }

\infrule[Struct-equiv]
{ P \scong Q }
{ \quotep{P} \nameeq \quotep{Q} }

\subsection{Substitution}

As is standard we use $P\id{\{}\vec{x_1} / \vec{x_0} \id{\}}$ to
denote capture-avoiding substitution of the names $\vec{x_1}$ for the
names $\vec{x_0}$. But, some care must be taken regarding
substitutions and quoted processes, i.e. $\quotep{P}$. 

Now, let $\Proc$ denote the set of processes and
$\QProc$ denote the set of names. Then, substitutions
are defined as partial maps, $s : \QProc \rightarrow \QProc$. These lift, uniquely, to maps $\dropn{s} :
\Proc \rightarrow \Proc$ by the following equations.

\begin{eqnarray*}
(0) \psubstp{Q}{P}         & = &    0 \\
(R \juxtap S) \psubstp{Q}{P}
		& = &    
		(R)\psubstp{Q}{P} \juxtap (S) \psubstp{Q}{P} \\
(x \id{(} y\id{)}\concat R) \psubstp{Q}{P}    
		& = &    
		(x)\substp{Q}{P} \id{(}z\id{)}\concat( (R \psubstn{z}{y}) \psubstp{Q}{P} ) \\
(x\id{[}y\id{]}) \psubstp{Q}{P}
		& = &    
		(x)\substp{Q}{P} \id{[}(y)\substp{Q}{P} \id{]} \\
(\lift{x}{R}) \psubstp{Q}{P}  
 		& = &
 		\lift{(x)\substp{Q}{P}}{ R \psubstp{Q}{P} } \\
(\dropn{x})  \psubstp{Q}{P}       
		& = & 
		\left\{ 
			\begin{array}{ccc} 
				Q & & x \nameeq \quotep{P} \\
                              	\dropn{x} & & otherwise \\
			\end{array}
		\right.
\end{eqnarray*}
 

where

\begin{equation*}
(x)\id{\{} \lpquote Q \rpquote / \lpquote P \rpquote \id{\}}            = 
		\left\{ 
			\begin{array}{ccc}
				\lpquote Q \rpquote & & x \nameeq \lpquote P \rpquote \\
                                x & & otherwise \\
			\end{array}
		\right.
\end{equation*}

and $z$ is chosen distinct from $\quotep{P}$, $\quotep{Q}$, the free
names in $Q$, and all the names in $R$.

Anticipating something of what's to come, these definitions should
make it clear that there is a significant difference between
$\lift{x}{P}$ and
$x\id{[}\lpquote P \rpquote\id{]}$. Specifically, consider the following pair of processes:

\begin{eqnarray*}
	\lift{w}{y \id{[}z\id{]}}\dropn{\id{\{}u / z \id{\}}}
		& = &
		\lift{w}{y \id{[}u\id{]}} \\
	w\id{[} \lpquote y\id{[}z\id{]} \rpquote \id{]} \rpquote \id{\{}u / z \id{\}} \lpquote
		& = &
		w\id{[} \lpquote y\id{[}z\id{]} \rpquote \id{]}
\end{eqnarray*}

Thus, the lift operator will be seen as a way to dynamically
construct processes before reifying them as names.

\begin{rem}
	Note that the substitution for alpha-equivalence, which -- by
	abuse of notation -- we write $\category{P}
	\substn{\category{x}_0}{\category{x}_1}$, will use name
	equivalence in its tests, but will not perform the drop. That
	is, its definition is identical to the one above, except for
	the following case.
\begin{equation*}
	(\dropn{x}) \substn{Q}{P}       
		= 
		\left\{ 
			\begin{array}{ccc} 
				\quotep{Q} & & x \nameeq \quotep{P} \\
                              	\dropn{x} & & otherwise \\
			\end{array}
		\right.	
\end{equation*}
\end{rem}

\begin{rem}
	The astute reader will have noticed that substitution is
	mutually recursive with $\nameeq$ and $\scong$. In particular,
	to carry out a substitution may require that one check the
	equivalence of two names. This may require that one check
	whether the processes they quote are structurally
	equivalent. This may require that one check that they are
	alpha-convertible. This, in turn, may require that one carry
	out a substitution!
	
	This does not present a problem, however, because each time
	around the circuit the names are getting strictly
	simpler. Ultimately, this recursion bottoms out in being able
	to check that $\pzero$ is the same as or structurally
	equivalent to $\pzero$. In other words, the mutual recursion
	is well-founded.
	
	Having observed the mutual recursion, however, it is now convenient to
	add one more structural equivalence law.
\end{rem}

\begin{eqnarray*}
 \category{P} \equiv \category{P} \substn{\category{x}_0}{\category{x}_1}, \; \mbox{\textit{if} }\category{x}_0 \nameeq \category{x}_1
\end{eqnarray*}

\subsection{Operational Semantics}
The reduction rules for {\rhoc}  are
% \infrule[Comm]
% { {\category{x}_0 \nameeq \category{x}_3} }
% {{{\category{x}_{0}\id{[}\category{x}_{2}\id{]}}} \juxtap {\category{x}_{3}\id{(}\category{x}_{1}\id{)} \concat \category{P}}
% \red \category{P}\id{\{}\category{x}_{2} \id{/} \category{x}_{1} \id{\}}}

\infrule[Comm]
{  }
{{{\category{x}_{0}\id{[}\category{x}_{2}\id{]}}} \juxtap {\category{x}_{0}\id{(}\category{x}_{1}\id{)} \concat \category{P}}
\red \category{P}\id{\{}\category{x}_{2} \id{/} \category{x}_{1} \id{\}}}

\infrule[Lift]
{  }
{{\lift{\category{x}}{\category{P}}}
\red \category{x}\id{[}\lpquote\category{P}\rpquote\id{]}}

In addition, we have the following context rules:

\infrule[Par]{\category{P}_0 \red \category{P}_1}{{\category{P}_0 \juxtap \category{P}_2} \red {\category{P}_1 \juxtap \category{P}_2}}

\infrule[Equiv]{{\category{P}_2 \scong \category{P}_0} \andalso {\category{P}_0 \red \category{P}_1} \andalso {\category{P}_1 \scong \category{P}_3}}{\category{P}_2 \red \category{P}_3}

We write $\wred$ for $\red^*$.

\section{Replication}

As mentioned before, it is known that replication (and hence
recursion) can be implemented in a higher-order process algebra
\cite{SangiorgiWalker}. As our first example of calculation with the
machinery thus far presented we give the construction explicitly in
the {\rhoc}.

% \begin{equation*}
% !P \triangleq \lift{x}{(x\id{(}y\id{)}\concat(\rpquote y\lpquote \juxtap x\id{[}y\id{]}) \juxtap P)} \juxtap x\id{(}z\id{)}\concat(\rpquote z\lpquote \juxtap x\id{[}z\id{]})
% \end{equation*}

\begin{eqnarray*}
	D(x) & \triangleq & \prefix{x}{y}{(\binpar{\outputp{x}{y}}{\dropn{y}})} \\
	\bangp{P}(x) & \triangleq & \binpar{\lift{x}{\binpar{D(x)}{P}}}{D(x)}
\end{eqnarray*}

\begin{eqnarray*}
	\bangp{P}(x) & & \\
	\triangleq
	& \lift{x}{(\prefix{x}{y}{(\outputp{x}{y} \juxtap \dropn{y})) \juxtap P}} 
	      \juxtap \prefix{x}{y}{(\outputp{x}{y} \juxtap \dropn{y})} & \\
	\red
	& \outputp{x}{\quotep{(\prefix{x}{y}{(\outputp{x}{y} \juxtap \dropn{y})) \juxtap P}}}
	  \juxtap \prefix{x}{y}{(\outputp{x}{y} \juxtap \dropn{y})} & \\
	\red
	& (\outputp{x}{y} \juxtap \dropn{y})\psubstn{\quotep{(\prefix{x}{y}{(\dropn{y} \juxtap \outputp{x}{y})) \juxtap P}}}{y} & \\
	\triangleq
	& \outputp{x}{\quotep{(\prefix{x}{y}{(\outputp{x}{y} \juxtap \dropn{y})) \juxtap P}}}
	  \juxtap {(\prefix{x}{y}{(\outputp{x}{y} \juxtap \dropn{y})) \juxtap P}} & \\
	\red
	& \ldots & \\
	\red
	& P \juxtap P \juxtap \ldots & \\
\end{eqnarray*}

Of course, this implementation runs away. The standard approach to a
more implementable replication operator is to restrict it to
input-guarded processes. E.g.,

\begin{equation*}
\bangp{\prefix{u}{v}{P}} 
	\triangleq 
	\prefix{u}{v}{(\binpar{\lift{x}{\binpar{(\prefix{u}{v}{D(x)})}{P}}}{D(x)})}
\end{equation*}

\section{Bisimulation}

Having taken the notion of restriction out of the language, we
carefully place it back into the notion of observation, and hence into
the notion of program equality, i.e. bisimulation. That is, we
parameterize the notion of barbed bisimulation by a set of names over
which we are allowed to set the barbs. 

% [Ed. note: suppose c is not in a barb set, can we make hidden links in
% programs? Does this screw up the notion of a parameterized barbed
% bisimulation?]

The motivation will become clearer when we treat the encoding of the
asynchronous {\pic}.

\begin{defn}
An \emph{observation relation}, $\downarrow_{\mathcal N}$, over a set
of names, $\mathcal N$, is the smallest relation satisfying the rules
below.

\infrule[Out-barb]{y \in {\mathcal N}, \; x \nameeq y}
		  {\outputp{x}{v} \downarrow_{\mathcal N} x}
\infrule[Par-barb]{\mbox{$P\downarrow_{\mathcal N} x$ or $Q\downarrow_{\mathcal N} x$}}
		  {\binpar{P}{Q} \downarrow_{\mathcal N} x}

We write $P \Downarrow_{\mathcal N} x$ if there is $Q$ such that 
$P \wred Q$ and $Q \downarrow_{\mathcal N} x$.
\end{defn}

Notice that $\prefix{x}{y}{P}$ has no barb.  Indeed, in {\rhoc} as well
as other asynchronous calculi, an observer has no direct means to
detect if a message sent has been received or not.

\begin{defn}
%\label{def.bbisim}
An  ${\mathcal N}$-\emph{barbed bisimulation} over a set of names, ${\mathcal N}$, is a symmetric binary relation 
${\mathcal S}_{\mathcal N}$ between agents such that $P\rel{S}_{\mathcal N}Q$ implies:
\begin{enumerate}
\item If $P \red P'$ then $Q \wred Q'$ and $P'\rel{S}_{\mathcal N} Q'$.
\item If $P\downarrow_{\mathcal N} x$, then $Q\Downarrow_{\mathcal N} x$.
\end{enumerate}
$P$ is ${\mathcal N}$-barbed bisimilar to $Q$, written
$P \wbbisim_{\mathcal N} Q$, if $P \rel{S}_{\mathcal N} Q$ for some barbed bisimulation $\mathcal S$.
\end{defn}

% \emph{Barbed congruence}, written $\fwbeq_{\mathcal N}$, is the largest
% ${\mathcal N}$-barbed bisimulation which is also a congruence.
% \end{defn}

% \begin{rem}
% 	Asking for congruence including contexts of the form
% 	$\lift{x}{\diamond}$ requires that $P \wbbisim Q$ implies that
% 	$\quotep{P} \nameeq \quotep{Q}$. This is too
% 	stringent. Instead we seek a weaker form of equivalence,
% 	closed only up to substitions.
% \end{rem}

% \begin{defn}
% $P$ is \emph{barbed equivalent} to $Q$, written $P \wbeq Q$, if and only if $P \sigma \parop R \wbbisim Q \sigma 
% \parop R$, for every $R$ and substitution $\sigma$.
% \end{defn}

% It is well-known that, due to the universal quantification over
% contexts, barbed congruence is hard to demonstrate.  A standard remedy
% mitigating this difficulty is the context lemma below.

% \begin{lem}
% %\label{contextlemma}
% $P \wbeq Q$ if and only if $P \sigma \parop R \wbbisim Q \sigma 
% \parop R$, for every $R$ and substitution $\sigma$.
% \end{lem}
% This lemma replaces the quantification over contexts 
% with a quantification over parallel contexts and substitutions, which
% is still hard to verify. 

\section{Interpreting \pic}

Here we provide an encoding of the pure asynchronous {\pic} into the {\rhoc}.

% \begin{rem}
% 	There are several ways to handle the treatment of free
% 	names. We lose no generality by asking that the translation be
% 	given an environment, i.e. an injective map, $r :
% 	\mathcal{N}_{\pi} \rightarrow \QProc$, mapping the free names
% 	into names in the {\rhoc}.
% \end{rem}

Since all names are global in the {\rhoc}, there is a small
complication in the treatment of free names. There are several ways to
handle this. One is to insist that the translation be handed a closed
program (one in which all names are bound either by input or by
restriction). Another is to provide an environment for the free names,
i.e. an injective map, $r : \mathcal{N}_{\pi} \rightarrow \QProc$,
mapping the free names into names in the {\rhoc}. Maintaining the
updates to the environment obscures the simplicity of the
translation. We adopt a third alternative.

Observe, again, that {\pic} is parameterized in a theory of names. So,
we build a {\pic} in which the names are the names of {\rhoc}. 

\subsection{\pic}

More formally,

\begin{grammar}
\mbox{\pic}		& \category{P}			& \bc	& \pzero \\
				&					& \bm	& \category{x}\id{[}\category{x}\id{]} \\
				&					& \bm	& \category{x}\id{(}\category{x}\id{)} \concat \category{P} \\
				&					& \bm	& \newp{\category{x}}{\category{P}} \\
				&					& \bm	& \category{P} \juxtap \category{P} \\
				&					& \bm	& \bangp{\category{P}} \\
				& \category{x}  		& \bc	& x \in \QProc
\end{grammar}

\subsection{Structural congruence}

\begin{defn}
The {\em structural congruence}, $\equiv$, between processes is 
the least congruence closed with respect to
alpha-renaming, satisfying the abelian monoid laws for 
parallel (associativity, commutativity and $\pzero$ 
as identity), and the following axioms:
\begin{enumerate}
\item the scope laws:
\begin{eqnarray*}
 \newp{x}\pzero  	& \equiv & \pzero, \\
 \newp{x}{\newp{x}{P}} 	& \equiv & \newp{x}{P}, \\
 \newp{x}{\newp{y}{P}} 	& \equiv & \newp{x}{\newp{y}{P}}, \\
 \binpar{P}{\newp{x}{Q}} & \equiv & \newp{x}{\binpar{P}{Q}}, \; \mbox{\textit{if} }x \not\in \freenames{P} 
\end{eqnarray*}
\item
the recursion law:
\begin{eqnarray*}
 \bangp{P} \equiv \binpar{P}{\bangp{P}}
\end{eqnarray*}
\item
the name equivalence law:
\begin{eqnarray*}
 P \equiv P \substn{x}{y}, \; \mbox{\textit{if} }x \nameeq y
\end{eqnarray*}
\end{enumerate}
\end{defn}

\subsection{Operational semantics} The operational semantics is standard.

\infrule[Comm]
{ }
{{{\category{x}_{0}\id{[}\category{x}_{2}\id{]}}} \juxtap {\category{x}_{0}\id{(}\category{x}_{1}\id{)} \concat \category{P}}
\red \category{P}\id{\{}\category{x}_{2} \id{/} \category{x}_{1} \id{\}}}

In addition, we have the following context rules:

\infrule[Par]{\category{P}_0 \red \category{P}_1}{{\category{P}_0 \juxtap \category{P}_2} \red {\category{P}_1 \juxtap \category{P}_2}}

\infrule[New]{\category{P}_0 \red \category{P}_1}{{\newp{\category{x}}{\category{P}_0}} \red {\newp{\category{x}}{\category{P}_1}}}

\infrule[Equiv]{{\category{P}_2 \scong \category{P}_0} \andalso {\category{P}_0 \red \category{P}_1} \andalso {\category{P}_1 \scong \category{P}_3}}{\category{P}_2 \red \category{P}_3}

We write $\wred$ for $\red^*$.

\subsection{The translation}

Given a process, $P$, we pick $n$ and $p$ such that $n \neq p$ and
distinct from the free names of $P$. For example, $n = \quotep{\Pi_{m
\in \freenames{P}}\outputp{m}{\quotep{\pzero}}}$ and $p =
\quotep{\Pi_{m \in
\freenames{P}}\prefix{m}{\quotep{\pzero}}{\pzero}}$. Then

\begin{equation*}
	\meaningof{P} = \meaningof{P}_{2nd}( n, p )
\end{equation*}

where

\begin{eqnarray*}
   	\meaningof{\pzero}_{2nd} (  n, p )
   		& = &
   		 \pzero \\
   	\meaningof{x \id{[} y \id{]}}_{2nd} (  n, p ) 
  		& = & 
  		x \id{[} y \id{]} \\
   	\meaningof{x \id{(} y \id{)} \concat P}_{2nd} (  n, p ) 
   		& = & 
 		x \id{(} y \id{)} \concat \meaningof{P}_{2nd} (  n, p ) \\
   	\meaningof{P \juxtap Q}_{2nd} (  n, p ) 
   		& = & 
 		\meaningof{P}_{2nd} ( n^{l}, p^{l} )
   			 \juxtap \meaningof{Q}_{2nd} ( n^{r}, p^{r} ) \\
%    	\meaningof{\id{!} P}_{2nd} (  n, p )
%    		& = & \binpar{\lift{x}{\binpar{upn( n^{lr}, p^{lr}, n^{rl}, p^{rl} )}
% 						      {\meaningof{P}_{3rd}( n^{lr}, p^{lr}, n^{rl}, p^{rl} )}}}
% 		             {\binpar{D(x)}{\binpar{\outputp{n^{lr}}{n}}{\outputp{p^{lr}}{p}}}} \\
   	\meaningof{\id{!} P}_{2nd} (  n, p )
   		& = & \binpar{\lift{x}{\meaningof{P}_{3rd}( n^{r}, p^{r} )}}
		             {\binpar{D(x)}{\binpar{\outputp{n^{r}}{n^{l}}}{\outputp{p^{r}}{p^{l}}}}} \\
   	\meaningof{\id{(}\nu \; x \id{)} P}_{2nd} (  n, p ) 
   		& = & 
 		\prefix{p}{x}{\binpar{\meaningof{P}_{2nd} ( n^{l}, p^{l} )}{\outputp{p}{n}}} \\
\end{eqnarray*}

where

\begin{eqnarray*}
	x^{l} & \triangleq & \quotep{\outputp{x}{x}} \\
	x^{r} & \triangleq & \quotep{\prefix{x}{x}{\pzero}} \\
	\meaningof{P}_{3rd}( n'', p'' ) 
		& \triangleq & 
			\prefix{n''}{n}{\prefix{p''}{p}{(\binpar{\meaningof{P}_{2nd}(  n, p )}
							        {(\binpar{D(x)}{\binpar{\outputp{n''}{n^{l}}}{\outputp{p''}{p^{l}}}})})}} \\
\end{eqnarray*}

\begin{rem}
	Note that all $\nu$-binding is now explicit, as in Wischik's global
	$\pi$-calculus. That is, the treatment of $\newp{x}{P}$ is as an input
	guard.
\end{rem}
	
\begin{rem}
	It is also noteworthy that the translation is dependent on how
	the parallel compositions in a process are
	associated. Different associations will result in different
	bindings for $\nu$-ed names. This will not result in different
	behavior, however, as the bindings will be consistent
	throughout the translation of the process.
\end{rem}

\begin{thm}[Correctness]	
	$P \wbbisim_{\pi} Q \iff \ldb P \rdb \wbbisim_{r(\texttt{FN}(P))} \ldb Q \rdb$.
\end{thm}

\emph{Proof sketch}: An easy structural induction.

It is important to note that there are contexts in the {\rhoc} that
will distinguish the translations. But, these are contexts that can
see the fresh names, $n$, and the communication channel, $p$, for the `memory
allocator'.

\begin{example}
	In a similar vein consider, for an appropriately chosen $p$ and $n$ we have
	\begin{equation*}
		\meaningof{\newp{v}{\newp{v}{\outputp{u}{v}}}} = 
			\binpar{\prefix{p}{v}{(\binpar{(\prefix{\quotep{\outputp{p}{p}}}{v}{\outputp{u}{v}})}
					              {(\outputp{\quotep{\outputp{p}{p}}}{\quotep{\outputp{n}{n}}})})}}
			       {\outputp{p}{n}}
	\end{equation*}
	and
	\begin{equation*}
		\meaningof{\newp{v}{\outputp{u}{v}}} = 
				\binpar	{\prefix{p}{v}{\outputp{u}{v}}}
			       		{\outputp{p}{n}}
	\end{equation*}

	Both programs will result in a fresh name bound to $v$. But,
	the former program will consume more resources. Two names will
	be allocated; two memory requests will be fulfilled. The
	{\rhoc} can see this, while the {\pic} cannot. This is
	entirely appropriate of a theory aimed at explaining some of
	the details of practical \emph{implementation}.
\end{example}

\subsection{Higher-order {\pic}}

As noted above, the lift and drop operators of the {\rhoc} effectively
give it features of a higher-order calculus without adding process
variables. The translation of the higher-order {\pic} is quite similar
to the translation for {\pic}. 

Of course, the higher-order {\pic} has application and one may wonder
how this is accomplished. This is where the susceptibility of lift to
substitutions comes in handy. For example, to translate the parallel
composition of a process that sends an abstraction, $\absp{v}{P}$, to a
process that receives it and applies it to the values, $v$ we calculate

\begin{eqnarray*}
	\meaningof{\binpar{\outputp{x}{\absp{v}{P}}}{(\prefix{x}{Y}{\applyp{Y}{v}})}}(z)
		= 
	\binpar{(\prefix{z}{v}{\lift{x}{\meaningof{P}(z')}})}
	       {(\binpar{\prefix{x}{y}{\dropn{y}}}{\outputp{z}{\meaningof{v}(z'')}})}
\end{eqnarray*}

where the translation is parameterized in a channel, $z$, for sending
values, and $z'$ and $z''$ are constructed from $z$ in some manner
analogous to what is done with $n$ and $p$ above.

\section{Examples}

\subsection{Durability}

Every process in the {\rhoc} is equivalent to a \emph{lift-saturated}
one, the translation defined on input by

\begin{eqnarray*}
	\meaningof{\prefix{x}{y}{P}} ( z )
		& = &
		 \prefix{x}{y}{( \lift{z}{\meaningof{P}( z )} \juxtap \prefix{z}{w}{\dropn{w}} )} \\
\end{eqnarray*}

and identity or recursion everywhere else. 

Lift saturation is very much like a continuation-passing style
interpretation of the {\rhoc}, where the continuation is now reified
and may be manipulated by an outer interpreter. For example, a
scheduler may be interposed between the lift of $P$ to $z$ and the
corresponding evaluating listener. Likewise, a store may be added to the mix. 

For example, let $Store(s)$ be a process, that takes storage requests on $s$ and set

\begin{eqnarray*}
	\meaningof{\prefix{x}{y}{P}} ( s, z )
		& = &
		 \prefix{x}{y}{( \lift{z}{\meaningof{P}( s, z )} 
				 \juxtap \prefix{z}{w}{\binpar{\dropn{w}}{\outputp{s}{w}}} )} \\
\end{eqnarray*}

Then, $\meaningof{\prefix{x}{y}{P}} ( s, z ) \juxtap Store(s)$ will
sequester copies of the continuations of input-guarded processes, in
the store. This serves as the basis for an approach to durability;
although, of course, the story is much more complex than this. For
example, how does one retrieve a continuation of a given shape or
description? This question provides a segue into the next section.

\subsection{Complex data}

The key idea behind how complex data, expressed as processes, may be
sent and received is to pattern match on the form of the process
sent. We achieve this by allowing inputs to be process forms that are
used to deconstruct the names supplied by output. Deconstruction is
effected by modifying the communication rule to reflect the pattern
matching.

% [Comm] 

%                 {x_0 \nameq x_3} 
% ------------------------------------------------- 
% { x_0[x_2] \juxtap x_3(x_1).P \red P\{x_2/x_1\} } 

\begin{grammar}
\mbox{\rhoc++}		& \category{P}			& \bc	& \pzero \\
				&					& \bm	& \category{x}\id{[}\category{x}\id{]} \\
				&					& \bm	& \category{x}\id{(}\category{m}\id{)} \concat \category{P} \\
				&					& \bm	& \lift{\category{x}}{\category{P}} \\
				&					& \bm	& \category{P} \juxtap \category{P} \\
				&					& \bm	& \dropn{\category{x}} \\
				& \category{m}			& \bc	& \pzero \\
				&					& \bm	& \category{x}\id{[}\category{x}\id{]} \\
				&					& \bm	& \category{x}\id{(}\category{x}\id{)} \concat \category{z} \\
				&					& \bm	& \lift{\category{x}}{\category{z}} \\
				&					& \bm	& \category{z} \juxtap \category{z} \\
				&					& \bm	& \dropn{\category{x}} \\
				& \category{z}			& \bc	& \category{x} \\
				&					& \bm	& \dropn{\category{x}} \\
				& \category{x}  		& \bc	& \quotep{\category{P}}
\end{grammar}

\infrule[Comm-zero] 
 { {\category{x}_0 \nameeq \category{x}_1} \andalso {\category{x}_2 \nameeq \quotep{0}} }
 { { \category{x}_0[\category{x}_2] \juxtap \category{x}_1(\pzero).\category{P} \red \category{P} } }

\infrule[Comm-write] 
	{ {\category{x}_0 \nameeq \category{x}_3} \\ 
     	  \exists \category{P}_1, \category{P}_2 . \quotep{\quotep{\category{P}_1}[\quotep{\category{P}_2}]} \nameeq \category{x}_2 }
	{ { \category{x}_0[\category{x}_2] \juxtap \category{x}_3(\category{x}_1[\category{x}_4]).\category{P} \red \category{P}\{\quotep{\category{P}_1}/\category{x}_1,\quotep{\category{P}_2}/\category{x}_4\} } }


\infrule[Comm-read] 
	{ {\category{x}_0 \nameeq \category{x}_3} \\ 
	  \exists \category{P}_1, \category{P}_2, \category{P}_3 . \quotep{\quotep{\category{P}_1}(\quotep{\category{P}_2}).\category{P}_3} \nameeq \category{x}_2 }
	{ { \category{x}_0[\category{x}_2] \juxtap \category{x}_3(\category{x}_1(\category{x}_4).\category{x}_5).\category{P} \red \category{P}\{\quotep{\category{P}_1}/\category{x}_1,\quotep{\category{P}_2}/\category{x}_4,\quotep{\category{P}_3}/\category{x}_5\} } }

\infrule[Comm-read-drop] 
	{ {\category{x}_0 \nameeq \category{x}_3} \\ 
	  \exists \category{P}_1, \category{P}_2, \category{P}_3 . \quotep{\quotep{\category{P}_1}(\quotep{\category{P}_2}).\dropn{\quotep{\category{P}_3}}} \nameeq \category{x}_2 }
	{ { \category{x}_0[\category{x}_2] \juxtap \category{x}_3(\category{x}_1(\category{x}_4).\category{x}_5).\category{P} \red \category{P}\{\quotep{\category{P}_1}/\category{x}_1,\quotep{\category{P}_2}/\category{x}_4,\quotep{\category{P}_3}/\category{x}_5\} } }

\infrule[Comm-lift] 
	{ {\category{x}_0 \nameeq \category{x}_3} \\ 
	  \exists \category{P}_1, \category{P}_2 . \quotep{\lift{\quotep{\category{P}_1}}{\category{P}_2}} \nameeq \category{x}_2 }
	{ { \category{x}_0[\category{x}_2] \juxtap \category{x}_3(\lift{\category{x}_1}{\category{x}_4}) \red \category{P}\{\quotep{\category{P}_1}/\category{x}_1,\quotep{\category{P}_2}/\category{x}_4\} } }

\infrule[Comm-lift-drop] 
	{ {\category{x}_0 \nameeq \category{x}_3} \\ 
	  \exists \category{P}_1, \category{P}_2 . \quotep{\lift{\quotep{\category{P}_1}}{\dropn{\quotep{\category{P}_2}}}} \nameeq \category{x}_2 }
	{ { \category{x}_0[\category{x}_2] \juxtap \category{x}_3(\lift{\category{x}_1}{\category{x}_4}) \red \category{P}\{\quotep{\category{P}_1}/\category{x}_1,\quotep{\category{P}_2}/\category{x}_4\} } }

\infrule[Comm-par] 
	{ {\category{x}_0 \nameeq \category{x}_3} \\ 
	  \exists \category{P}_1, \category{P}_2 . \category{P}_1 \not\equiv \pzero, \category{P}_2 \not\equiv \pzero, \quotep{\category{P}_1 \juxtap \category{P}_2} \nameeq \category{x}_2 }
	{ { \category{x}_0[\category{x}_2] \juxtap \category{x}_3(\category{x}_1 \juxtap \category{x}_4).\category{P} \red \category{P}\{\quotep{\category{P}_1}/\category{x}_1,\quotep{\category{P}_2}/\category{x}_4\} } }

\infrule[Comm-par-drop] 
	{ {\category{x}_0 \nameeq \category{x}_3} \\ 
	  \exists \category{P}_1, \category{P}_2 . \category{P}_1 \not\equiv \pzero, \category{P}_2 \not\equiv \pzero, \quotep{\dropn{\quotep{\category{P}_1}} \juxtap \dropn{\quotep{\category{P}_2}}} \nameeq \category{x}_2 }
	{ { \category{x}_0[\category{x}_2] \juxtap \category{x}_3(\category{x}_1 \juxtap \category{x}_4).\category{P} \red \category{P}\{\quotep{\category{P}_1}/\category{x}_1,\quotep{\category{P}_2}/\category{x}_4\} } }


% \infrule[Comm-eval] 
% 	{ {\category{x}_0 \nameeq \category{x}_3} \\ 
% 	  \exists \category{P}_1 . \quotep{\category{P}_1} \nameeq \category{x}_2 }
% 	{ { \category{x}_0[\category{x}_2] \juxtap \category{x}_3(\dropn{\category{x}_1}).\category{P} \red \category{P}\{\quotep{\category{P}_1}/\category{x}_1\} } }

The effect of this change is to make the language lexically
reflective. Every syntactic form is now reified and communication is
dispatched on the basis of these forms.

Now imagine that our store from the previous example is parameterized
on a port for get requests, $Store(s,g)$. While not realistic, we
might imagine a protocol in which the client of the store gives it a
port to which the store broadcasts the entire store. The client can
then pick out those process forms that are of interest using the
pattern matching from above.

A slightly more realistic version of this is that the client
subscribes not to the entire store, but to a view of the store. Only
the view is broadcast to the port on which the client is
pattern-matching. An even more realistic version has the client
quoting the pattern-matching process and shipping that to the
store. The store evaluates the pattern-matching process which ships
matches back to the client. We say this latter version is more
realistic because it more closely mimics what happens in a relational
database system where the query is sent from the client to the server,
evaluated at the server and the results sent back.

To recapitulate, the client of the store requests of the store three
ports: a port, $m$, on which to send the pattern-matching process, a
port, $v$, for a view of the data, and a port, $r$, on which to ship
back results to the client. Thus, a client reporting on a channel $a$
the continuations of stored processes that were blocked on input would
look like this:

% \begin{eqnarray*}
% 	spm( c ) & \triangleq & \quotep{\outputp{c}{c}} \\
% 	cvd( c ) & \triangleq & \quotep{\prefix{c}{c}{\pzero}} \\
% 	rslt( c ) & \triangleq & \quotep{\binpar{\dropn{c}}{\dropn{c}}} \\
% \end{eqnarray*}
\begin{eqnarray*}
	client( s, g, c, a ) & \triangleq & 
	 \outputp{g}{c} 
	  \juxtap \prefix{c}
			 {\prefix{m}{v}{r}}
			 {(\lift{m}{!\prefix{v}{\prefix{x}{y}{z}}{\outputp{r}{\quotep{\prefix{x}{y}{z}}}}} 
			   \juxtap !\prefix{r}{\prefix{x}{y}{z}}{\outputp{a}{z}})} \\
\end{eqnarray*}

\subsection{Macros}

The reader that has gotten this far will have already seen the basic
ingredients of a macro system a la \texttt{Scheme} \cite{r5rs}. Quote
and eval in the {\rhoc} work very much like quote and eval in
\texttt{Scheme}. Interestingly, input-guarded lift works much like
backquote and comma. 

When these features are combined with the pattern-matching-based
lexical reflection the system is fairly expressive. The reader is
invited to try, as a test of this claim, writing a process that will
convert a process into it's lift-saturated form.

\section{Conclusions and future work}

We have briefly studied a construction for adding reflection to
name-passing calculi. The study was conducted in a concurrency
setting, applying the construction to the async {\pic}. We were
motivated to study this theory by the observation that many practical
examples of features that might be desirable in a programming language
based on mobile process algebras involve serialization and
deserialization of program state, or program source data.

We considered how the asynchronous {\pic} may be embedded into such a
theory. Additionally, we touched briefly on the chief features of some
examples that indicate this as a promising direction.

We should also mention that there is a wider context in which we view
this work. On the theoretical side, we note that Carbone and Maffeis
observe a tower of expressiveness resulting from adding very simple
structure to names \cite{polysync}. In some sense, this may be view as
approaching the phenomena of structured names `from below'. By making
names be processes, this work may be seen as approaching the same
phenomena `from above'. But, both investigations are really the
beginnings of a much longer and deeper investigation of the
relationship between process structure and name structure.

On the applications side, such an investigation may be highly
warranted in light of the recent connection between concurrency theory
and biology. In particular, despite the interesting results achieved
by researchers in this field, there is a fundamental difference
between the kind of synchronization observed in the {\pic} and the
kind of synchronization observed between molecules at the
bio-molecular level. The difference is that interactions in the latter
case occur at sites with extension and behavior of their own
\cite{Fontana}. An account of this phenomenon may be revealed in a
detailed study of the relationship between the structure of names and
the structure of processes.

\paragraph{Acknowledgments.}
The authors thank Lucian Wischik for his thoughtful and careful
reading of previous drafts of this paper.

% ------------------------------------------------------------------------
%GATHER{Xbib.bib}   % For Gather Purpose Only
%GATHER{Paper.bbl}  % For Gather Purpose Only
\bibliographystyle{amsplain}
\bibliography{concur_rho_2004}

% ------------------------------------------------------------------------

% ------------------------------------------------------------------------

\end{document}
% ------------------------------------------------------------------------
