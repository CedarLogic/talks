% ------------------------------------------------------------------------
% AMS-LaTeX Paper ********************************************************
% ------------------------------------------------------------------------
% Submitted:      Dec 15 2003
% Final Version:  
% Accepted:       
% ------------------------------------------------------------------------
% This is a journal top-matter template file for use with AMS-LaTeX.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\documentclass{tran-l}
%\documentclass[twocolumn]{amsart}
\documentclass[]{amsart}
%\documentclass[]{llncs}

%\usepackage[active]{srcltx} % SRC Specials for DVI Searching
\usepackage{url}

% From Allen's stable.
\usepackage{bigpage}
\usepackage{bcprules}
\usepackage{code}
\usepackage{amsfonts}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{caption}
\usepackage{multicol}

% Double brackets
\newcommand{\ldb}{[\![}
\newcommand{\rdb}{]\!]}
\newcommand{\lliftb}{\langle\!|}
\newcommand{\rliftb}{|\!\rangle}
% \newcommand{\lpquote}{\langle}
% \newcommand{\rpquote}{\rangle}
% \newcommand{\lpquote}{\lceil}
% \newcommand{\rpquote}{\rceil}
\newcommand{\lpquote}{\ulcorner}
\newcommand{\rpquote}{\urcorner}
\newcommand{\newkw}{\nu}

% SYNTAX
\newcommand{\id}[1]{\texttt{#1}}
\newcommand{\none}{\emptyset}
\newcommand{\eps}{\epsilon}
\newcommand{\set}[1]{\{#1\}}
\newcommand{\rep}[2]{\id{\{$#1$,$#2$\}}}
\newcommand{\elt}[2]{\id{$#1$[$#2$]}}
\newcommand{\infinity}{$\infty$}

\newcommand{\pzero}{\mathbin{0}}
\newcommand{\seq}{\mathbin{\id{,}}}
\newcommand{\all}{\mathbin{\id{\&}}}
\newcommand{\choice}{\mathbin{\id{|}}}
\newcommand{\altern}{\mathbin{\id{+}}}
\newcommand{\juxtap}{\mathbin{\id{|}}}
\newcommand{\concat}{\mathbin{.}}
\newcommand{\punify}{\mathbin{\id{:=:}}}
\newcommand{\fuse}{\mathbin{\id{=}}}
\newcommand{\scong}{\mathbin{\equiv}}
\newcommand{\nameeq}{\mathbin{\equiv_N}}
\newcommand{\alphaeq}{\mathbin{\equiv_{\alpha}}}
\newcommand{\names}[1]{\mathbin{\mathcal{N}(#1)}}
\newcommand{\freenames}[1]{\mathbin{\mathcal{FN}(#1)}}
\newcommand{\boundnames}[1]{\mathbin{\mathcal{BN}(#1)}}
%\newcommand{\lift}[2]{\texttt{lift} \; #1 \concat #2}
\newcommand{\binpar}[2]{#1 \juxtap #2}
\newcommand{\outputp}[2]{#1 \id{[} #2 \id{]}}
\newcommand{\prefix}[3]{#1 \id{(} #2 \id{)} \concat #3}
\newcommand{\lift}[2]{#1 \lliftb #2 \rliftb}
\newcommand{\quotep}[1]{\lpquote #1 \rpquote}
\newcommand{\dropn}[1]{\rpquote #1 \lpquote}

\newcommand{\newp}[2]{\id{(}\newkw \; #1 \id{)} #2}
\newcommand{\bangp}[1]{\id{!} #1}

\newcommand{\substp}[2]{\id{\{} \quotep{#1} / \quotep{#2} \id{\}}}
\newcommand{\substn}[2]{\id{\{} #1 / #2 \id{\}}}

\newcommand{\psubstp}[2]{\widehat{\substp{#1}{#2}}}
\newcommand{\psubstn}[2]{\widehat{\substn{#1}{#2}}}

\newcommand{\applyp}[2]{#1 \langle #2 \rangle}
\newcommand{\absp}[2]{\id{(} #1 \id{)} #2}

\newcommand{\transitions}[3]{\mathbin{#1 \stackrel{#2}{\longrightarrow} #3}}
\newcommand{\meaningof}[1]{\ldb #1 \rdb}

\newcommand{\Proc}{\mathbin{Proc}}
\newcommand{\QProc}{\quotep{\mathbin{Proc}}}

\newcommand{\entailm}{\mathbin{\vdash_{\mathfrak m}}} %matching
\newcommand{\entailp}{\mathbin{\vdash_{\mathfrak p}}} %behavioral
\newcommand{\entailv}{\mathbin{\vdash_{\mathfrak v}}} %validation
\newcommand{\congd}{\mathbin{\equiv_{\mathfrak d}}}
\newcommand{\congs}{\mathbin{\equiv_{\mathfrak s}}}
\newcommand{\congp}{\mathbin{\equiv_{\mathfrak p}}}
%\newcommand{\logequiv}{\mathbin{\leftrightarrow}}

\newcommand{\barb}[2]{\mathbin{#1 \downarrow_{#2}}}
\newcommand{\dbarb}[2]{\mathbin{#1 \Downarrow_{#2}}}

% From pi-duce paper
\newcommand{\red}{\rightarrow}
\newcommand{\wred}{\Rightarrow}
\newcommand{\redhat}{\hat{\longrightarrow}}
\newcommand{\lred}[1]{\stackrel{#1}{\longrightarrow}} %transitions
\newcommand{\wlred}[1]{\stackrel{#1}{\Longrightarrow}}

\newcommand{\opm}[2]{\overline{#1} [ #2 ]} % monadic
\newcommand{\ipm}[2]{{#1} ( #2 )} 
\newcommand{\ipmv}[2]{{#1} ( #2 )} % monadic
\newcommand{\parop}{\;|\;}		% parallel operator
\newcommand{\patmatch}[3]{#2 \in #3 \Rightarrow #1}
\newcommand{\sdot}{\, . \,}		% Space around '.'
\newcommand{\bang}{!\,}
%\newcommand{\fuse}[1]{\langle #1 \rangle}		
\newcommand{\fusion}[2]{#1 = #2} % fusion prefix/action
\newcommand{\rec}[2]{\mbox{\textsf{rec}} \, #1. \, #2}
\newcommand{\match}[2]{\mbox{\textsf{match}} \; #1 \; \mbox{\textsf{with}} \; #2}
\newcommand{\sep}{:}
\newcommand{\val}[2]{\mbox{\textsf{val}} \; #1 \; \mbox{\textsf{as}} \; #2}

\newcommand{\rel}[1]{\;{\mathcal #1}\;} %relation
\newcommand{\bisim}{\stackrel{.}{\sim}_b} %bisimilar
\newcommand{\wb}{\approx_b} %weak bisimilar
\newcommand{\bbisim}{\stackrel{\centerdot}{\sim}} %barbed bisimilar
\newcommand{\wbbisim}{\stackrel{\centerdot}{\approx}} %weak barbed bisimilar
\newcommand{\bxless}{\lesssim}	%expansion less (amssymb required)
\newcommand{\bxgtr}{\gtrsim}	%expansion greater (amssymb required)
\newcommand{\beq}{\sim}		%barbed congruent
\newcommand{\fwbeq}{\stackrel{\circ}{\approx}}	%weak barbed congruent
\newcommand{\wbeq}{\approx}	%weak barbed congruent
\newcommand{\sheq}{\simeq}	%symbolic hypereq
\newcommand{\wbc}{\approx_{cb}}

% End piduce contribution

\newcommand{\typedby}{\mathbin{\:\colon}}
\newcommand{\mixedgroup}[1]{\id{mixed($#1$)}}
\newcommand{\cast}[2]{\id{CAST AS} \; #1 \; (#2)}
\newcommand{\bslsh}{\mathbin{\id{\\}}}
\newcommand{\bslshslsh}{\mathbin{\id{\\\\}}}
\newcommand{\fslsh}{\mathbin{\id{/}}}
\newcommand{\fslshslsh}{\mathbin{\id{//}}}
\newcommand{\bb}[1]{\mbox{#1}}
\newcommand{\bc}{\mathbin{\mathbf{::=}}}
\newcommand{\bm}{\mathbin{\mathbf\mid}}
\newcommand{\be}{\mathbin{=}}
\newcommand{\bd}{\mathbin{\buildrel {\rm \scriptscriptstyle def} \over \be}}
\newcommand{\category}[1]{\mbox{\bf #1}}

%GRAMMAR
\newlength{\ltext}
\newlength{\lmath}
\newlength{\cmath}
\newlength{\rmath}
\newlength{\rtext}

\settowidth{\ltext}{complex type name}
\settowidth{\lmath}{$xxx$}
\settowidth{\cmath}{$::=$}
\settowidth{\rmath}{\id{attributeGroup}}
\settowidth{\rtext}{repetition of $g$ between $m$ and $n$ times}

\newenvironment{grammar}{
  \[
  \begin{array}{l@{\quad}rcl@{\quad}l}
  \hspace{\ltext} & \hspace{\lmath} & \hspace{\cmath} & \hspace{\rmath} & \hspace{\rtext} \\
}{
  \end{array}\]
}

% Over-full v-boxes on even pages are due to the \v{c} in author's name
\vfuzz2pt % Don't report over-full v-boxes if over-edge is small

% THEOREM Environments ---------------------------------------------------
 \newtheorem{thm}{Theorem}[subsection]
 \newtheorem{cor}[thm]{Corollary}
 \newtheorem{lem}[thm]{Lemma}
 \newtheorem{prop}[thm]{Proposition}
 \theoremstyle{definition}
 \newtheorem{defn}[thm]{Definition}
 \theoremstyle{remark}
 \newtheorem{rem}[thm]{Remark}
 \newtheorem{example}[thm]{Example}
 \numberwithin{equation}{subsection}
% MATH -------------------------------------------------------------------
 \DeclareMathOperator{\RE}{Re}
 \DeclareMathOperator{\IM}{Im}
 \DeclareMathOperator{\ess}{ess}
 \newcommand{\veps}{\varepsilon}
 \newcommand{\To}{\longrightarrow}
 \newcommand{\h}{\mathcal{H}}
 \newcommand{\s}{\mathcal{S}}
 \newcommand{\A}{\mathcal{A}}
 \newcommand{\J}{\mathcal{J}}
 \newcommand{\M}{\mathcal{M}}
 \newcommand{\W}{\mathcal{W}}
 \newcommand{\X}{\mathcal{X}}
 \newcommand{\BOP}{\mathbf{B}}
 \newcommand{\BH}{\mathbf{B}(\mathcal{H})}
 \newcommand{\KH}{\mathcal{K}(\mathcal{H})}
 \newcommand{\Real}{\mathbb{R}}
 \newcommand{\Complex}{\mathbb{C}}
 \newcommand{\Field}{\mathbb{F}}
 \newcommand{\RPlus}{\Real^{+}}
 \newcommand{\Polar}{\mathcal{P}_{\s}}
 \newcommand{\Poly}{\mathcal{P}(E)}
 \newcommand{\EssD}{\mathcal{D}}
 \newcommand{\Lom}{\mathcal{L}}
 \newcommand{\States}{\mathcal{T}}
 \newcommand{\abs}[1]{\left\vert#1\right\vert}
% \newcommand{\set}[1]{\left\{#1\right\}}
%\newcommand{\seq}[1]{\left<#1\right>}
 \newcommand{\norm}[1]{\left\Vert#1\right\Vert}
 \newcommand{\essnorm}[1]{\norm{#1}_{\ess}}

%%% NAMES
\newcommand{\Names}{{\mathcal N}}
\newcommand{\Channels}{{\sf X}}
\newcommand{\Variables}{{\mathcal V}}
\newcommand{\Enames}{{\mathcal E}}
\newcommand{\Nonterminals}{{\mathcal S}}
\newcommand{\Pnames}{{\mathcal P}}
\newcommand{\Dnames}{{\mathcal D}}
\newcommand{\Types}{{\mathcal T}}

\newcommand{\fcalc}{fusion calculus}
\newcommand{\xcalc}{${\mathfrak x}$-calculus}
\newcommand{\lcalc}{$\lambda$-calculus}
\newcommand{\pic}{$\pi$-calculus}
\newcommand{\rhoc}{$\rho$-calculus}
\newcommand{\ambc}{ambient calculus}
\newcommand{\hcalc}{highwire calculus}
\newcommand{\dcalc}{data calculus}
%XML should be all caps, not small caps. --cb
%\newcommand{\xml}{\textsc{xml}}
\newcommand{\xml}{XML} 

\newcommand{\papertitle}{A reflective higher-order calculus fully-abstractly encodes ambients}
% use static date to preserve date of actual publication
 \newcommand{\paperversion}{Draft Version 0.1 - December 21, 2004}

\newenvironment{toc}
{
\begin{list}{}{
   \setlength{\leftmargin}{0.4in}
   \setlength{\rightmargin}{0.6in}
   \setlength{\parskip}{0pt}
 } \item }
{\end{list}}

\newenvironment{narrow}
{
\begin{list}{}{
   \setlength{\leftmargin}{0.4in}
   \setlength{\rightmargin}{0.6in}
 } \item }
{\end{list}}

%%% ----------------------------------------------------------------------
\begin{document}

%These margin values appear to be relative to the bigpage package settings. --cb
\setlength{\topmargin}{0in}
\setlength{\textheight}{8.5in}
\setlength{\parskip}{6pt}

%\title{\huge{\papertitle}}
\title{\papertitle}

\author{ Walter Fontana }
\author{ L.G. Meredith }
\author{ Matthias Radestock }

%\address{Systems Biology, Harvard Medical School, Boston, Massachussetts, USA}

%\email{lg_meredith@hms.harvard.edu}

%\thanks{This work was completed during a visiting appointment at the Department of Systems Biology, Harvard Medical School.}

%\subjclass{Primary 47A15; Secondary 46A32, 47D20}

\keywords{concurrency, message-passing, process calculus, reflection}

%\date{April 6, 2002.}

\dedicatory{}

%\commby{Daniel J. Rudolph}

%%% ----------------------------------------------------------------------

\begin{abstract}
\normalsize{ 

Comm rule with splitting allows to encode out rule of ambients. Lift
and drop allows to encode in rule of ambients. Communication allows
for open.

}

\end{abstract}

\noindent
{\large \textbf{Notes on ambient rho}}\\
\rule{6.25in}{0.75pt}\\\\\\

%%% ----------------------------------------------------------------------
\maketitle
%%% ----------------------------------------------------------------------

% \begin{center}
% \paperversion\\
% \end{center}

% \begin{toc}
% \tableofcontents
% \end{toc}

% \newpage
% ------------------------------------------------------------------------

\section{Introduction}

Blah, blah, blah...

\subsection{Overview and contributions} 

We illustrate an encoding of the ambient calculus.

%%% ----------------------------------------------------------------------

\section{The calculus}

\subsubsection{Notation}

We let ${P, Q, R}$ range over processes and ${x, y, z}$ range over names.

\begin{grammar}
\mbox{\rhoc}		& {P, Q}		& \bc	& \pzero & \mbox{null process} \\
%				&					& \bm	& {x}\id{[}{y}\id{]} & \mbox{output} \\
				&					& \bm	& {x}\id{(}{y}\id{)} \concat {P} & \mbox{input} \\
				&					& \bm	& \lift{{x}}{{P}} & \mbox{lift} \\
				&					& \bm	& \dropn{{x}} & \mbox{ drop } \\
				&					& \bm	& {P} \juxtap {Q} & \mbox{ parallel } \\
				& {x, y}  		& \bc	& \quotep{{P}} & \mbox{ quote } \\
\end{grammar}

\subsubsection{Input and output}

The input constructor is standard for an asynchronous name-passing
calculus. Input blocks its continuation from execution until it
receives a communication. Lift is a form of output which -- because
the calculus is asynchronous -- is allowed no continuation. It also
affords a convenient syntactic sugar, which we define here.

\begin{equation*}
	{x}\id{[}{y}\id{]} \triangleq \lift{x}{\dropn{y}}
\end{equation*}

\subsection{Free and bound names}

The syntax has been chosen so that a binding occurrence of a name is
sandwiched between round braces, $\id{(} \cdot \id{)}$. Thus, the
calculation of the free names of a process, $P$, denoted
$\freenames{P}$ is given recursively by

%\begin{multicols}{2}
%{
	\begin{eqnarray*}
		\freenames{\pzero} & = & \emptyset \\
%		\freenames{x \id{[}y\id{]}} & = & \{ x, y \} \\
		\freenames{x \id{(}y\id{)} \concat P} & = & \{ x \} \cup (\freenames{P} \setminus \{ y \}) \\
		\freenames{\lift{x}{P}} & = & \{ x \} \cup \freenames{P} \\
		\freenames{\binpar{P}{Q}} & = & \freenames{P} \cup \freenames{Q} \\
		\freenames{\dropn{x}} & = & \{ x \} \\
	\end{eqnarray*}
%}
%\end{multicols}

An occurrence of $x$ in a process $P$ is \textit{bound} if it is not
free. The set of names occurring in a process (bound or free) is
denoted by $\names{P}$.

\subsection{Structural congruence}

The {\em structural congruence} of processes, noted $\scong$, is the
least congruence, containing $\alpha$-equivalence, $\alphaeq$, that
satisfies the following laws:

\begin{eqnarray*}
	{P} \juxtap \pzero	
		&  \scong \; {P} \; \scong & 
			\pzero \juxtap {P} \\
	{P} \juxtap {Q}	
		& \scong & 
			{Q} \juxtap {P} \\
	({P} \juxtap {Q}) \juxtap {R}
		& \scong & 
			{P} \juxtap ({Q} \juxtap {R}) \\
\end{eqnarray*}

\subsection{Name equivalence}

We now come to one of the first real subtleties of this calculus. Both
the calculation of the free names of a process and the determination
of structural congruence between processes critically depend on being
able to establish whether two names are equal. In the case of the
calculation of the free names of an input-guarded process, for
example, to remove the bound name we must determine whether it is in
the set of free names of the continuation. Likewise, structural
congruence includes $\alpha$-equivalence. But, establishing
$\alpha$-equivalence between the processes $x \id{(} z \id{)}\concat \lift{w}{y
\id{[}z\id{]}}$ and $x \id{(} v \id{)}\concat \lift{w}{y
\id{[}v\id{]}}$, for instance, requires calculating a substitution, e.g. $x \id{(} v \id{)}\concat \lift{w}{y
\id{[}v\id{]}} \id{\{}z / v \id{\}}$. But this calculation requires, in turn, being able to
determine whether two names, in this case the name in the object
position of the output, and the name being substituted for, are equal.

As will be seen, the equality on names involves structural equivalence
on processes, which in turn involves alpha equivalence, which involves
name equivalence. This is a subtle mutual recursion, but one that
turns out to be well-founded. Before presenting the technical details,
the reader may note that the grammar above enforces a strict
alternation between quotes and process constructors. Each question
about a process that involves a question about names may in turn
involve a question about processes, but the names in the processes the
next level down, as it were, are under fewer quotes. To put it another
way, each `recursive call' to name equivalence will involve one less
level of quoting, ultimately bottoming out in the quoted zero process.

Let us assume that we have an account of (syntactic) substitution and
$\alpha$-equivalence upon which we can rely to formulate a notion of
name equivalence, and then bootstrap our notions of substitution and
$\alpha$-equivalence from that. We take name equivalence, written
$\nameeq$, to be the smallest equivalence relation generated by the
following rules.


\infrule[Quote-drop]
{  }
{ \quotep{\dropn{x}} \nameeq x }

\infrule[Struct-equiv]
{ P \scong Q }
{ \quotep{P} \nameeq \quotep{Q} }

\subsection{Syntactic substitution}

Now we build the substitution used by $\alpha$-equivalence. We use
$\Proc$ for the set of processes, $\QProc$ for the set of names, and
$\id{\{}\vec{y} / \vec{x} \id{\}}$ to denote partial maps, $s : \QProc
\rightarrow \QProc$. A map, $s$ lifts, uniquely, to a map on process terms, $\widehat{s} :
\Proc \rightarrow \Proc$ by the following equations.

\begin{eqnarray*}
(0) \psubstp{Q}{P}         & = &    0 \\
(R \juxtap S) \psubstp{Q}{P}
		& = &    
		(R)\psubstp{Q}{P} \juxtap (S) \psubstp{Q}{P} \\
(x \id{(} y\id{)}\concat R) \psubstp{Q}{P}    
		& = &    
		(x)\substp{Q}{P} \id{(}z\id{)}\concat( (R \psubstn{z}{y}) \psubstp{Q}{P} ) \\
%(x\id{[}y\id{]}) \psubstp{Q}{P}
%		& = &    
%		(x)\substp{Q}{P} \id{[}(y)\substp{Q}{P} \id{]} \\
(\lift{x}{R}) \psubstp{Q}{P}  
 		& = &
 		\lift{(x)\substp{Q}{P}}{ R \psubstp{Q}{P} } \\
(\dropn{x})  \psubstp{Q}{P}       
		& = & 
		\left\{ 
			\begin{array}{ccc} 
				\dropn{\quotep{Q}} & & x \nameeq \quotep{P} \\
                              	\dropn{x} & & otherwise \\
			\end{array}
		\right.
\end{eqnarray*}
 

where

\begin{equation*}
(x)\id{\{} \lpquote Q \rpquote / \lpquote P \rpquote \id{\}}            = 
		\left\{ 
			\begin{array}{ccc}
				\lpquote Q \rpquote & & x \nameeq \lpquote P \rpquote \\
                                x & & otherwise \\
			\end{array}
		\right.
\end{equation*}

and $z$ is chosen distinct from $\quotep{P}$, $\quotep{Q}$, the free
names in $Q$, and all the names in $R$. Our $\alpha$-equivalence will
be built in the standard way from this substitution.

But, given these mutual recursions, the question is whether the calculation
of $\nameeq$ (respectively, $\scong$, $\alphaeq$) terminates. To
answer this question it suffices to formalize our intuitions regarding
level of quotes, or quote depth, $\#(x)$, of a name $x$ as
follows.

\begin{eqnarray*}
	\#(\quotep{P}) & = & 1 + \#(P) \\
    \#(P) & = & \left\{
			   \begin{array}{ccc}
				 max\{ \#(x) : x \in \names{P} \} & & \names{P} \neq \emptyset \\
				 0 & & otherwise \\
			   \end{array}
			\right.
\end{eqnarray*}

The grammar ensures that $\#(\quotep{P})$ is bounded. Then the
termination of $\nameeq$ (respectively, $\scong$, $\alphaeq$) is an
easy induction on quote depth.

\subsection{Semantic substitution}

The substitution used in $\alpha$-equivalence is really only a device
to formally recognize that binding occurrences do not depend on the
specific names. It is not the engine of computation. The proposal here
is that while synchronization is the driver of that engine, the real
engine of computation is a semantic notion of substitution that
recognizes that a dropped name is a request to run a process. Which
process? Why the one whose code has been bound to the name being
dropped. Formally, this amounts to a notion of substitution that
differs from syntactic substitution in its application to a dropped
name.

\begin{eqnarray*}
(\dropn{x})  \psubstp{Q}{P}       
		& = & 
		\left\{ 
			\begin{array}{ccc} 
				Q & & x \nameeq \quotep{P} \\
                              	\dropn{x} & & otherwise \\
			\end{array}
		\right.
\end{eqnarray*}

In the remainder of the paper we will refer to semantic and syntactic
substitutions simply as substitutions and rely on context to
distinguish which is meant. Similarly, we will abuse notation and
write $\substn{y}{x}$ for $\psubstn{y}{x}$.

Finally equipped with these standard features we can present the
dynamics of the calculus.

\subsection{Operational Semantics}
The reduction rules for {\rhoc}  are
% \infrule[Comm]
% { {{x}_0 \nameeq {x}_3} }
% {{{{x}_{0}\id{[}{x}_{2}\id{]}}} \juxtap {{x}_{3}\id{(}{x}_{1}\id{)} \concat {P}}
% \red {P}\id{\{}{x}_{2} \id{/} {x}_{1} \id{\}}}

%\infrule[Comm]
%{ {x}_{0} \nameeq {x}_{1} }
%{{{ x_{0} \id{[} z \id{]}}} \juxtap { x_{1} \id{(} y \id{)} \concat {P}}
%\red {P}\id{\{} z \id{/} y \id{\}}}

\infrule[Comm]
{ {x}_{0} \nameeq {x}_{1} }
{{\lift{x_{0}}{Q \juxtap R} \juxtap { x_{1} \id{(}{y} \id{)} \concat {P}}}
\red \lift{x_{0}}{R} \juxtap {P}\id{\{}\quotep{Q} \id{/} {y} \id{\}}}

In addition, we have the following context rules:

\infrule[Par]{{P} \red {P}'}{{{P} \juxtap {Q}} \red {{P}' \juxtap {Q}}}

\infrule[Equiv]{{{P} \scong {P}'} \andalso {{P}' \red {Q}'} \andalso {{Q}' \scong {Q}}}{{P} \red {Q}}

The context rules are entirely standard and we do not say much about
them, here. The communication rule does what was promised, namely make
it possible for agents to synchronize and communicate processes
packaged as names. 

\section{Replication}

As mentioned before, it is known that replication (and hence
recursion) can be implemented in a higher-order process algebra
\cite{SangiorgiWalker}. As our first example of calculation with the
machinery thus far presented we give the construction explicitly in
the {\rhoc}.

\begin{eqnarray*}
	D(x) & \triangleq & \prefix{x}{y}{(\binpar{\outputp{x}{y}}{\dropn{y}})} \\
	\bangp{P}(x) & \triangleq & \binpar{\lift{x}{\binpar{D(x)}{P}}}{D(x)}
\end{eqnarray*}

Of course, this encoding, as an implementation, runs away, unfolding
$\bangp{P}$ eagerly. A lazier and more implementable replication
operator, restricted to input-guarded processes, may be obtained as follows.

\begin{equation*}
\bangp{\prefix{u}{v}{P}} 
	\triangleq 
	\binpar{\lift{x}{\prefix{u}{v}{(\binpar{D(x)}{P})}}}{D(x)}
\end{equation*}

\section{Bisimulation}

Having taken the notion of restriction out of the language, we
carefully place it back into the notion of observation, and hence into
the notion of program equality, i.e. bisimulation. That is, we
parameterize the notion of barbed bisimulation by a set of names over
which we are allowed to set the barbs. The motivation for this choice
is really comparison with other calculi. The set of names of the
{\rhoc} is \textit{global}. It is impossible, in the grammar of
processes, to guard terms from being placed into contexts that can
potentially observe communication. So, we provide a place for
reasoning about such limitations on the scope of observation in the
theory of bisimulation.

% [Ed. note: suppose c is not in a barb set, can we make hidden links in
% programs? Does this screw up the notion of a parameterized barbed
% bisimulation?]
%will become clearer when we treat the encoding of the asynchronous {\pic}.

\begin{defn}
An \emph{observation relation}, $\downarrow_{\mathcal N}$, over a set
of names, $\mathcal N$, is the smallest relation satisfying the rules
below.

\infrule[Out-barb]{y \in {\mathcal N}, \; x \nameeq y}
		  {\outputp{x}{v} \downarrow_{\mathcal N} x}
\infrule[Par-barb]{\mbox{$P\downarrow_{\mathcal N} x$ or $Q\downarrow_{\mathcal N} x$}}
		  {\binpar{P}{Q} \downarrow_{\mathcal N} x}

We write $P \Downarrow_{\mathcal N} x$ if there is $Q$ such that 
$P \wred Q$ and $Q \downarrow_{\mathcal N} x$.
\end{defn}

Notice that $\prefix{x}{y}{P}$ has no barb.  Indeed, in {\rhoc} as well
as other asynchronous calculi, an observer has no direct means to
detect if a message sent has been received or not.

\begin{defn}
%\label{def.bbisim}
An  ${\mathcal N}$-\emph{barbed bisimulation} over a set of names, ${\mathcal N}$, is a symmetric binary relation 
${\mathcal S}_{\mathcal N}$ between agents such that $P\rel{S}_{\mathcal N}Q$ implies:
\begin{enumerate}
\item If $P \red P'$ then $Q \wred Q'$ and $P'\rel{S}_{\mathcal N} Q'$.
\item If $P\downarrow_{\mathcal N} x$, then $Q\Downarrow_{\mathcal N} x$.
\end{enumerate}
$P$ is ${\mathcal N}$-barbed bisimilar to $Q$, written
$P \wbbisim_{\mathcal N} Q$, if $P \rel{S}_{\mathcal N} Q$ for some ${\mathcal N}$-barbed bisimulation ${\mathcal S}_{\mathcal N}$.
\end{defn}

% \emph{Barbed congruence}, written $\fwbeq_{\mathcal N}$, is the largest
% ${\mathcal N}$-barbed bisimulation which is also a congruence.
% \end{defn}

% \begin{rem}
% 	Asking for congruence including contexts of the form
% 	$\lift{x}{\diamond}$ requires that $P \wbbisim Q$ implies that
% 	$\quotep{P} \nameeq \quotep{Q}$. This is too
% 	stringent. Instead we seek a weaker form of equivalence,
% 	closed only up to substitions.
% \end{rem}

% \begin{defn}
% $P$ is \emph{barbed equivalent} to $Q$, written $P \wbeq Q$, if and only if $P \sigma \parop R \wbbisim Q \sigma 
% \parop R$, for every $R$ and substitution $\sigma$.
% \end{defn}

% It is well-known that, due to the universal quantification over
% contexts, barbed congruence is hard to demonstrate.  A standard remedy
% mitigating this difficulty is the context lemma below.

% \begin{lem}
% %\label{contextlemma}
% $P \wbeq Q$ if and only if $P \sigma \parop R \wbbisim Q \sigma 
% \parop R$, for every $R$ and substitution $\sigma$.
% \end{lem}
% This lemma replaces the quantification over contexts 
% with a quantification over parallel contexts and substitutions, which
% is still hard to verify. 

\section{Review of ambient calculus}

We review Cardelli and Gordon's ambient calculus.

\subsection{Syntax}

\begin{grammar}
\mbox{\ambc}	& {P, Q}			& \bc	& \pzero & \mbox{null process} \\
				&					& \bm	& \newp{n}{P} & \mbox{restriction} \\
				&					& \bm	& {P} \juxtap {Q} & \mbox{ parallel } \\
				&					& \bm	& \bangp{P} & \mbox{ replication } \\
				&					& \bm	& {n}\id{[}{P}\id{]} & \mbox{ ambient } \\
				&					& \bm	& {M} \concat {P} & \mbox{ action } \\
				& {M}				& \bc	& {in \; n} & \mbox{ can enter n } \\
				&					& \bm	& {out \; n} & \mbox{ can exit n } \\
				&					& \bm	& {open \; n} & \mbox{ can open n } \\
				& {n}   			& \bc	& \quotep{{P}} & \mbox{ quote } \\
\end{grammar}

...

\subsubsection{Free names}

\begin{eqnarray*}
	\freenames{\pzero} & = & \emptyset \\
    \freenames{\newp{n}{P}} & = & \freenames{P} \setminus \{ n \} \\
	\freenames{\binpar{P}{Q}} & = & \freenames{P} \cup \freenames{Q} \\
	\freenames{\bangp{P}} & = & \freenames{P} \\
	\freenames{{n}\id{[}{P}\id{]}} & = & \freenames{P} \cup \{ n \} \\
	\freenames{{M} \concat {P}} & = & \freenames{P} \cup \freenames{M} \\
\end{eqnarray*}

\begin{eqnarray*}
	\freenames{{in \; n}} & = & \{ n \} \\
	\freenames{{out \; n}} & = & \{ n \} \\
	\freenames{{open \; n}} & = & \{ n \} \\
\end{eqnarray*}

\subsection{Structural congruence}

The {\em structural congruence} of processes, noted $\scong$, is the
least congruence, containing $\alpha$-equivalence, $\alphaeq$, that
satisfies the following laws:

\begin{eqnarray*}
	{P} \juxtap \pzero	
		&  \scong \; {P} \; \scong & 
			\pzero \juxtap {P} \\
	{P} \juxtap {Q}	
		& \scong & 
			{Q} \juxtap {P} \\
	({P} \juxtap {Q}) \juxtap {R}
		& \scong & 
			{P} \juxtap ({Q} \juxtap {R}) \\
	\bangp{P} & \scong & {P} \juxtap \bangp{P} \\
	\newp{n}{\newp{m}{P}} & \scong & \newp{m}{\newp{n}{P}} \\
	\newp{n}{{P} \juxtap {Q}} & \scong & {P} \juxtap \newp{n}{Q} \\
	\newp{n}{ {m} \id{[} {P} \id{]} } & \scong & {m} \id{[} \newp{m}{P} \id{]} \\
	\newp{n}{ 0 } & \scong & 0 \\
	\bangp{ 0 } & \scong & 0 \\
\end{eqnarray*}

\subsection{Semantics}

The operational semantics.

\infrule[Enter]
{}
{{n}\id{[}{in \; {m}} \concat {P} \juxtap {Q} \id{]} \juxtap {m}\id{[}{R}\id{]} 
 \red {m}\id{[}{n}\id{[}{P}\juxtap {Q}\id{]}\juxtap {R}\id{]}}

\infrule[Exit]
{}
{{m}\id{[}{n}\id{[}{out \; m}\concat {P} \juxtap {Q}\id{]} \juxtap {R} \id{]}
 \red {n}\id{[}{P}\juxtap {Q}\id{]}\juxtap {m}\id{[}{R}\id{]}}

\infrule[Open]
{}
{ {open \; n}\concat{ P} \juxtap {n} \id{[} {Q} \id{]} 
 \red {P} \juxtap {Q} }

\infrule[Res]{{P} \red {P}'}{{\newp{n}{P}} \red {\newp{n}{P'}}}

\infrule[Par]{{P} \red {P}'}{{{P} \juxtap {Q}} \red {{P}' \juxtap {Q}}}

\infrule[Equiv]{{{P} \scong {P}'} \andalso {{P}' \red {Q}'} \andalso {{Q}' \scong {Q}}}{{P} \red {Q}}

\section{Encoding ambients}

We exhibit terms for each of the ambient rules, $in$, $out$ and $open$.

\begin{eqnarray*}
	\lift{x}{P} \juxtap \prefix{x}{y}{\lift{z}{Q \juxtap \lift{x}{\dropn{y}}}} 
	& \red^* & \lift{z}{Q \juxtap \lift{x}{P}} \\
    \lift{x}{\lift{y}{\lift{x}{Q} \juxtap R}} 
	\juxtap \prefix{x}{z}{\dropn{z} 
				\juxtap \prefix{y}{w}{\dropn{w} \juxtap \prefix{x}{u}{\lift{y}{\dropn{u}}}}}
	& \red^* & \lift{x}{R} \juxtap \lift{y}{Q} \\
    \lift{x}{P} \juxtap \prefix{x}{y}{\dropn{y} \juxtap Q} & \red & P \juxtap Q \\
\end{eqnarray*}

Note: this is only a sketch of the fully-abstract encoding. The
processes above have other reductions in addition to the
ambient-behaviors. We have to lock down various pieces of processes to
emulate the ambient behavior.

The translation will be given by a function, $\meaningof{-}( -, - ) :
\Proc_{amb} \times \QProc \times \QProc \red \Proc$. The guiding
intuition is that we construct alongside the process a distributed memory
allocator, the process' access to which is mediated through the second argument
to the function. The first argument determines the shape of the memory
for the given allocator.

Given a process, $P$, we pick $n$ and $p$ such that $n \neq p$ and
distinct from the free names of $P$. For example, $n = \quotep{\Pi_{m
\in \freenames{P}}\outputp{m}{\quotep{\pzero}}}$ and $p =
\quotep{\Pi_{m \in
\freenames{P}}\prefix{m}{\quotep{\pzero}}{\pzero}}$. Then

\begin{equation*}
	\meaningof{P} = \meaningof{P}_{2nd}( n, p )
\end{equation*}

where

\begin{eqnarray*}
   	\meaningof{\pzero}_{2nd} (  n, p )
   		& = &
   		 \pzero \\
   	\meaningof{x \id{[} {P} \id{]}}_{2nd} (  n, p ) 
  		& = & 
  		\lift{x}{\meaningof{P}_{2nd} (  n, p )} \\
   	\meaningof{ {M} \concat P}_{2nd} (  n, p ) 
   		& = & 
 		... \\
   	\meaningof{P \juxtap Q}_{2nd} (  n, p ) 
   		& = & 
 		\meaningof{P}_{2nd} ( n^{l}, p^{l} )
   			 \juxtap \meaningof{Q}_{2nd} ( n^{r}, p^{r} ) \\
   	\meaningof{\id{!} P}_{2nd} (  n, p )
   		& = & \binpar{\lift{x}{\meaningof{P}_{3rd}( n^{r}, p^{r} )}}
		             {\binpar{D(x)}{\binpar{\outputp{n^{r}}{n^{l}}}{\outputp{p^{r}}{p^{l}}}}} \\
   	\meaningof{\id{(}\nu \; x \id{)} P}_{2nd} (  n, p ) 
   		& = & 
 		\prefix{p}{x}{\binpar{\meaningof{P}_{2nd} ( n^{l}, p^{l} )}{\outputp{p}{n}}} \\
\end{eqnarray*}

and

\begin{eqnarray*}
	x^{l} & \triangleq & \quotep{\outputp{x}{x}} \\
	x^{r} & \triangleq & \quotep{\prefix{x}{x}{\pzero}} \\
	\meaningof{P}_{3rd}( n'', p'' ) 
		& \triangleq & 
			\prefix{n''}{n}{\prefix{p''}{p}{(\binpar{\meaningof{P}_{2nd}(  n, p )}
							        {(\binpar{D(x)}{\binpar{\outputp{n''}{n^{l}}}{\outputp{p''}{p^{l}}}})})}} \\
\end{eqnarray*}

\begin{rem}
	Note that all $\nu$-binding is now interpreted, as in Wischik's
	global $\pi$-calculus, as an input guard \cite{globalpi}.
\end{rem}
	
\begin{rem}
	It is also noteworthy that the translation is dependent on how
	the parallel compositions in a process are
	associated. Different associations will result in different
	bindings for $\nu$-ed names. This will not result in different
	behavior, however, as the bindings will be consistent
	throughout the translation of the process.
\end{rem}

\begin{thm}[Correctness]	
	$P \wbbisim_{amb} Q \iff \ldb P \rdb \wbbisim_{r(\texttt{FN}(P))} \ldb Q \rdb$.
\end{thm}

\emph{Proof sketch}: An easy structural induction.

One key point in the proof is that there are contexts in the {\rhoc}
that will distinguish the translations. But, these are contexts that
can see the fresh names, $n$, and the communication channel, $p$, for
the `memory allocator'. These contexts do not correspond to any
observation that can be made in the {\pic} and so we exclude them in
the {\rhoc} side of our translation by our choice of ${\mathcal N}$
for the bisimulation. This is one of the technical motivations behind
our introduction of a less standard bisimulation.

\section{Conclusions and future work}

Blah, blah, blah, ambients, blah...

\paragraph{Acknowledgments.}
The authors wish to acknowledge sleeplessness and chocolate.

% ------------------------------------------------------------------------
%GATHER{Xbib.bib}   % For Gather Purpose Only
%GATHER{Paper.bbl}  % For Gather Purpose Only
\bibliographystyle{amsplain}
\bibliography{ex_nihilo}

% ------------------------------------------------------------------------

% ------------------------------------------------------------------------

\end{document}
% ------------------------------------------------------------------------
