% ------------------------------------------------------------------------
% AMS-LaTeX Paper ********************************************************
% ------------------------------------------------------------------------
% Submitted:      Dec 15 2003
% Final Version:  
% Accepted:       
% ------------------------------------------------------------------------
% This is a journal top-matter template file for use with AMS-LaTeX.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\documentclass{tran-l}
%\documentclass[twocolumn]{amsart}
\documentclass[]{amsart}
%\documentclass[]{llncs}

%\usepackage[active]{srcltx} % SRC Specials for DVI Searching
\usepackage{url}

% From Allen's stable.
\usepackage{bigpage}
\usepackage{bcprules}
\usepackage{code}
\usepackage{amsfonts}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{caption}
\usepackage{multicol}

% Double brackets
\newcommand{\ldb}{[\![}
\newcommand{\rdb}{]\!]}
\newcommand{\lliftb}{\langle\!|}
\newcommand{\rliftb}{|\!\rangle}
% \newcommand{\lpquote}{\langle}
% \newcommand{\rpquote}{\rangle}
% \newcommand{\lpquote}{\lceil}
% \newcommand{\rpquote}{\rceil}
\newcommand{\lpquote}{\ulcorner}
\newcommand{\rpquote}{\urcorner}
\newcommand{\newkw}{\nu}

% SYNTAX
\newcommand{\id}[1]{\texttt{#1}}
\newcommand{\none}{\emptyset}
\newcommand{\eps}{\epsilon}
\newcommand{\set}[1]{\{#1\}}
\newcommand{\rep}[2]{\id{\{$#1$,$#2$\}}}
\newcommand{\elt}[2]{\id{$#1$[$#2$]}}
\newcommand{\infinity}{$\infty$}

\newcommand{\pzero}{\mathbin{0}}
\newcommand{\seq}{\mathbin{\id{,}}}
\newcommand{\all}{\mathbin{\id{\&}}}
\newcommand{\choice}{\mathbin{\id{|}}}
\newcommand{\altern}{\mathbin{\id{+}}}
\newcommand{\juxtap}{\mathbin{\id{|}}}
\newcommand{\concat}{\mathbin{\id{.}}}
\newcommand{\punify}{\mathbin{\id{:=:}}}
\newcommand{\fuse}{\mathbin{\id{=}}}
\newcommand{\scong}{\mathbin{\equiv}}
\newcommand{\nameeq}{\mathbin{\equiv_N}}
\newcommand{\alphaeq}{\mathbin{\equiv_{\alpha}}}
\newcommand{\freenames}[1]{\mathbin{\mathcal{FN}(#1)}}
\newcommand{\boundnames}[1]{\mathbin{\mathcal{BN}(#1)}}
%\newcommand{\lift}[2]{\texttt{lift} \; #1 \concat #2}
\newcommand{\binpar}[2]{#1 \juxtap #2}
\newcommand{\outputp}[2]{#1 \id{[} #2 \id{]}}
\newcommand{\prefix}[3]{#1 \id{(} #2 \id{)} \concat #3}
\newcommand{\lift}[2]{#1 \lliftb #2 \rliftb}
\newcommand{\quotep}[1]{\lpquote #1 \rpquote}
\newcommand{\dropn}[1]{\rpquote #1 \lpquote}

\newcommand{\newp}[2]{\id{(}\newkw \; #1 \id{)} #2}
\newcommand{\bangp}[1]{\id{!} #1}

\newcommand{\substp}[2]{\id{\{} \quotep{#1} / \quotep{#2} \id{\}}}
\newcommand{\substn}[2]{\id{\{} #1 / #2 \id{\}}}

\newcommand{\psubstp}[2]{\dropn{\substp{#1}{#2}}}
\newcommand{\psubstn}[2]{\dropn{\substn{#1}{#2}}}

\newcommand{\applyp}[2]{#1 \langle #2 \rangle}
\newcommand{\absp}[2]{\id{(} #1 \id{)} #2}

\newcommand{\transitions}[3]{\mathbin{#1 \stackrel{#2}{\longrightarrow} #3}}
\newcommand{\meaningof}[1]{\ldb #1 \rdb}

\newcommand{\Proc}{\mathbin{Proc}}
\newcommand{\QProc}{\quotep{\mathbin{Proc}}}

\newcommand{\entailm}{\mathbin{\vdash_{\mathfrak m}}} %matching
\newcommand{\entailp}{\mathbin{\vdash_{\mathfrak p}}} %behavioral
\newcommand{\entailv}{\mathbin{\vdash_{\mathfrak v}}} %validation
\newcommand{\congd}{\mathbin{\equiv_{\mathfrak d}}}
\newcommand{\congs}{\mathbin{\equiv_{\mathfrak s}}}
\newcommand{\congp}{\mathbin{\equiv_{\mathfrak p}}}
%\newcommand{\logequiv}{\mathbin{\leftrightarrow}}

\newcommand{\barb}[2]{\mathbin{#1 \downarrow_{#2}}}
\newcommand{\dbarb}[2]{\mathbin{#1 \Downarrow_{#2}}}

% From pi-duce paper
\newcommand{\red}{\rightarrow}
\newcommand{\wred}{\Rightarrow}
\newcommand{\redhat}{\hat{\longrightarrow}}
\newcommand{\lred}[1]{\stackrel{#1}{\longrightarrow}} %transitions
\newcommand{\wlred}[1]{\stackrel{#1}{\Longrightarrow}}

\newcommand{\opm}[2]{\overline{#1} [ #2 ]} % monadic
\newcommand{\ipm}[2]{{#1} ( #2 )} 
\newcommand{\ipmv}[2]{{#1} ( #2 )} % monadic
\newcommand{\parop}{\;|\;}		% parallel operator
\newcommand{\patmatch}[3]{#2 \in #3 \Rightarrow #1}
\newcommand{\sdot}{\, . \,}		% Space around '.'
\newcommand{\bang}{!\,}
%\newcommand{\fuse}[1]{\langle #1 \rangle}		
\newcommand{\fusion}[2]{#1 = #2} % fusion prefix/action
\newcommand{\rec}[2]{\mbox{\textsf{rec}} \, #1. \, #2}
\newcommand{\match}[2]{\mbox{\textsf{match}} \; #1 \; \mbox{\textsf{with}} \; #2}
\newcommand{\sep}{:}
\newcommand{\val}[2]{\mbox{\textsf{val}} \; #1 \; \mbox{\textsf{as}} \; #2}

\newcommand{\rel}[1]{\;{\mathcal #1}\;} %relation
\newcommand{\bisim}{\stackrel{.}{\sim}_b} %bisimilar
\newcommand{\wb}{\approx_b} %weak bisimilar
\newcommand{\bbisim}{\stackrel{\centerdot}{\sim}} %barbed bisimilar
\newcommand{\wbbisim}{\stackrel{\centerdot}{\approx}} %weak barbed bisimilar
\newcommand{\bxless}{\lesssim}	%expansion less (amssymb required)
\newcommand{\bxgtr}{\gtrsim}	%expansion greater (amssymb required)
\newcommand{\beq}{\sim}		%barbed congruent
\newcommand{\fwbeq}{\stackrel{\circ}{\approx}}	%weak barbed congruent
\newcommand{\wbeq}{\approx}	%weak barbed congruent
\newcommand{\sheq}{\simeq}	%symbolic hypereq
\newcommand{\wbc}{\approx_{cb}}

% End piduce contribution

\newcommand{\typedby}{\mathbin{\:\colon}}
\newcommand{\mixedgroup}[1]{\id{mixed($#1$)}}
\newcommand{\cast}[2]{\id{CAST AS} \; #1 \; (#2)}
\newcommand{\bslsh}{\mathbin{\id{\\}}}
\newcommand{\bslshslsh}{\mathbin{\id{\\\\}}}
\newcommand{\fslsh}{\mathbin{\id{/}}}
\newcommand{\fslshslsh}{\mathbin{\id{//}}}
\newcommand{\bb}[1]{\mbox{#1}}
\newcommand{\bc}{\mathbin{\mathbf{::=}}}
\newcommand{\bm}{\mathbin{\mathbf\mid}}
\newcommand{\be}{\mathbin{=}}
\newcommand{\bd}{\mathbin{\buildrel {\rm \scriptscriptstyle def} \over \be}}
\newcommand{\category}[1]{\mbox{\bf #1}}

%GRAMMAR
\newlength{\ltext}
\newlength{\lmath}
\newlength{\cmath}
\newlength{\rmath}
\newlength{\rtext}

\settowidth{\ltext}{complex type name}
\settowidth{\lmath}{$xxx$}
\settowidth{\cmath}{$::=$}
\settowidth{\rmath}{\id{attributeGroup}}
\settowidth{\rtext}{repetition of $g$ between $m$ and $n$ times}

\newenvironment{grammar}{
  \[
  \begin{array}{l@{\quad}rcl@{\quad}l}
  \hspace{\ltext} & \hspace{\lmath} & \hspace{\cmath} & \hspace{\rmath} & \hspace{\rtext} \\
}{
  \end{array}\]
}

% Over-full v-boxes on even pages are due to the \v{c} in author's name
\vfuzz2pt % Don't report over-full v-boxes if over-edge is small

% THEOREM Environments ---------------------------------------------------
 \newtheorem{thm}{Theorem}[subsection]
 \newtheorem{cor}[thm]{Corollary}
 \newtheorem{lem}[thm]{Lemma}
 \newtheorem{prop}[thm]{Proposition}
 \theoremstyle{definition}
 \newtheorem{defn}[thm]{Definition}
 \theoremstyle{remark}
 \newtheorem{rem}[thm]{Remark}
 \newtheorem{example}[thm]{Example}
 \numberwithin{equation}{subsection}
% MATH -------------------------------------------------------------------
 \DeclareMathOperator{\RE}{Re}
 \DeclareMathOperator{\IM}{Im}
 \DeclareMathOperator{\ess}{ess}
 \newcommand{\veps}{\varepsilon}
 \newcommand{\To}{\longrightarrow}
 \newcommand{\h}{\mathcal{H}}
 \newcommand{\s}{\mathcal{S}}
 \newcommand{\A}{\mathcal{A}}
 \newcommand{\J}{\mathcal{J}}
 \newcommand{\M}{\mathcal{M}}
 \newcommand{\W}{\mathcal{W}}
 \newcommand{\X}{\mathcal{X}}
 \newcommand{\BOP}{\mathbf{B}}
 \newcommand{\BH}{\mathbf{B}(\mathcal{H})}
 \newcommand{\KH}{\mathcal{K}(\mathcal{H})}
 \newcommand{\Real}{\mathbb{R}}
 \newcommand{\Complex}{\mathbb{C}}
 \newcommand{\Field}{\mathbb{F}}
 \newcommand{\RPlus}{\Real^{+}}
 \newcommand{\Polar}{\mathcal{P}_{\s}}
 \newcommand{\Poly}{\mathcal{P}(E)}
 \newcommand{\EssD}{\mathcal{D}}
 \newcommand{\Lom}{\mathcal{L}}
 \newcommand{\States}{\mathcal{T}}
 \newcommand{\abs}[1]{\left\vert#1\right\vert}
% \newcommand{\set}[1]{\left\{#1\right\}}
%\newcommand{\seq}[1]{\left<#1\right>}
 \newcommand{\norm}[1]{\left\Vert#1\right\Vert}
 \newcommand{\essnorm}[1]{\norm{#1}_{\ess}}

%%% NAMES
\newcommand{\Names}{{\mathcal N}}
\newcommand{\Channels}{{\sf X}}
\newcommand{\Variables}{{\mathcal V}}
\newcommand{\Enames}{{\mathcal E}}
\newcommand{\Nonterminals}{{\mathcal S}}
\newcommand{\Pnames}{{\mathcal P}}
\newcommand{\Dnames}{{\mathcal D}}
\newcommand{\Types}{{\mathcal T}}

\newcommand{\fcalc}{fusion calculus}
\newcommand{\xcalc}{${\mathfrak x}$-calculus}
\newcommand{\lcalc}{$\lambda$-calculus}
\newcommand{\pic}{$\pi$-calculus}
\newcommand{\rhoc}{$\rho$-calculus}
\newcommand{\hcalc}{highwire calculus}
\newcommand{\dcalc}{data calculus}
%XML should be all caps, not small caps. --cb
%\newcommand{\xml}{\textsc{xml}}
\newcommand{\xml}{XML} 

\newcommand{\papertitle}{Reflective higher-order process algebra with applications to biological systems}
% use static date to preserve date of actual publication
 \newcommand{\paperversion}{Draft Version 0.1 - June 30, 2004}

\newenvironment{toc}
{
\begin{list}{}{
   \setlength{\leftmargin}{0.4in}
   \setlength{\rightmargin}{0.6in}
   \setlength{\parskip}{0pt}
 } \item }
{\end{list}}

\newenvironment{narrow}
{
\begin{list}{}{
   \setlength{\leftmargin}{0.4in}
   \setlength{\rightmargin}{0.6in}
 } \item }
{\end{list}}

%%% ----------------------------------------------------------------------
\begin{document}

%These margin values appear to be relative to the bigpage package settings. --cb
\setlength{\topmargin}{0in}
\setlength{\textheight}{8.5in}
\setlength{\parskip}{6pt}

\title{\papertitle}

\author{ L.G. Meredith }

%\address{Microsoft Corporation, Redmond, Washington, USA}

%\email{gregmer@microsoft.com}

%\thanks{This work was completed under the BigTop project.}

%\subjclass{Primary 47A15; Secondary 46A32, 47D20}

\keywords{concurrency, distribution, message-passing, process calculus, service-oriented architecture, quality of service, service level agreement}

%\date{April 6, 2002.}

\dedicatory{}

%\commby{Daniel J. Rudolph}

%%% ----------------------------------------------------------------------

\begin{abstract}
\normalsize{ 

The {\pic} is a theory parametric in a theory of
\textit{names}. Standard presentations assume a supply of names and a
theory of equality on them. This point is made abundantly clear in
such presentations by the grammar describing terms of the language:
there is no production for names. Names are taken to be terminals in
the grammar. While traditional presentations treat names as atomic, it
is of theoretical interest to study what happens when names have
structure. For example, recent work by Carbone and Maffeis reveals a
tower of calculi of increasing expressiveness resulting by taking
names to be tuples of some fixed length. \cite{polysync}. Adding
structure to names also turns out to be of interest from an
applications perspective. In Microsoft's BizTalk Process
Orchestration, for example, the notion of binding was developed to
provide a way of specifying the structure of names and how that mapped
names onto various transport technologies.

Calculi admitting structured names may have even broader applications,
however. A number of researchers have been applying the {\pic} to
modeling biochemical and biological systems
\cite{Regevbiomolecularprocesses}. But, as Walter Fontana of Harvard
Systems Biology observes, there is a fundamental difference between
the kind of synchronization observed in the {\pic} and the kind of
synchronization observed between molecules at the bio-molecular
level. Specifically, interactions in the latter case occur at sites
with \emph{extension} and \emph{behavior} of their own. We feel
strongly that an account of this kind of physical phenomenon may be
revealed in a detailed study of the relationship between the structure
of names and the structure of processes.

To this end, we observe that the work of Carbone and Maffeis can be
viewed as approaching the phenomena of structured names `from below'
in the sense that they add a minimal structure to names. It is also
possible to approach such a study `from above.' We have observed very
recently that there is a general construction for name-passing
calculi, like the {\pic}, for adding \emph{reflection} to such
calculi. The construction makes it possible to turn \emph{program
terms} into names, and names back into program terms. An attractive
feature of this study, from a theoretical perspective, is that the
algebra on names is selected by the algebra on programs. In this sense
it is `maximal', justifying the phrase `from above', but also
providing at least one answer to the question of \emph{which}
structure to put on names.

}

\end{abstract}

\noindent
{\large \textbf{
Trento research proposal}}\\
\rule{6.25in}{0.75pt}\\\\\\

%%% ----------------------------------------------------------------------
\maketitle
%%% ----------------------------------------------------------------------

% \begin{center}
% \paperversion\\
% \end{center}

% \begin{toc}
% \tableofcontents
% \end{toc}

% \newpage
% ------------------------------------------------------------------------

\section{Introduction}

The {\pic} is a theory parametric in a theory of \textit{names}
\cite{milner91polyadicpi}. Standard presentations assume a supply of
names and a theory of equality on them. This point is made abundantly
clear in such presentations by the grammar describing terms of the
language: there is no production for names. Names are taken to be
terminals in the grammar. While traditional presentations treat names
as atomic, it is of theoretical interest to study what happens when
names have structure. For example, recent work by Carbone and Maffeis
reveals a tower of calculi of increasing expressiveness resulting by
taking names to be tuples of some fixed
length. \cite{polysync}. Adding structure to names also turns out to
be of interest from an applications perspective. In Microsoft's
BizTalk Process Orchestration, for example, the notion of binding was
developed to provide a way of specifying the structure of names and
how that mapped names onto various transport technologies.

Calculi admitting structured names may have even broader applications,
however. A number of researchers have been applying the {\pic} to
modeling biochemical and biological systems
\cite{Regevbiomolecularprocesses}. But, as Walter Fontana of Harvard
Systems Biology observes, there is a fundamental difference between
the kind of synchronization observed in the {\pic} and the kind of
synchronization observed between molecules at the bio-molecular
level. Specifically, interactions in the latter case occur at sites
with \emph{extension} and \emph{behavior} of their own. We feel
strongly that an account of this kind of physical phenomenon may be
revealed in a detailed study of the relationship between the structure
of names and the structure of processes.

To this end, we observe that the work of Carbone and Maffeis can be
viewed as approaching the phenomena of structured names `from below'
in the sense that they add a minimal structure to names. It is also
possible to approach such a study `from above.' We have observed very
recently that there is a general construction for name-passing
calculi, like the {\pic}, for adding \emph{reflection} to such
calculi. The construction makes it possible to turn \emph{program
terms} into names, and names back into program terms. An attractive
feature of this study, from a theoretical perspective, is that the
algebra on names is selected by the algebra on programs. In this sense
it is `maximal', justifying the phrase `from above', but also
providing at least one answer to the question of \emph{which}
structure to put on names.

The approach appealing in another practical way: reflection has proven
to be a generally useful feature in modern programming languages,
e.g. Java, C{\#} \cite{JavaReflection} and others. The ability to turn
program into data and back is an essential capability that shows up in
basic language constructs like macros systems and even recursion.

We propose to study this reflective construction for name-passing
calculi in the context of the {\pic} with an emphasis on biological
applications. The investigation will cover 

\begin{description}

	\item [theory] developing an operational semantics as well
	as a stochastic interpretation; a combinator-based variant
	and a denotational semantics;

	\item [applications] developing two case studies focusing on
	signal pathways: one to show that existing work can be treated
	in this framework; another to demonstrate the power of adding
	extension to names;

	\item [implementation] providing a functioning virtual machine
	and a design for a combinator-based instruction set

\end{description}

Trento seems an ideal institution in which to carry out this
investigation. Priami's group is world-class in its understanding both
of mobile process algebras and their application to biological
systems. In their work on {$\beta$-binders} they have already instigated
an alternative investigation of a structured-name-based calculus. We
see our work as complementary. Additionally, Priami is the inventor of
the stochastic {\pic} \cite{priamistochasticpi}. He is an ideal collaborator for an
investigation of stochastic interpretations of a reflective system.

\section{Proposal}

\subsection{Theory}

\paragraph{Operational semantics} 

We have already developed an operational semantics (see
appendix). But, there are subtle issues around the mutual recursion
between structural equivalence, name equivalence and alpha
equivalence. This needs to be carefully developed, debugged and
reviewed by the community.

\paragraph{Combinators} 

Yoshida has given a beautiful combinatorial account of the {\pic}
\cite{YoshidaGraphCombinators}. To the best of our knowledge, this is
the only account of the {\pic} providing a separability result,
indicating expressiveness of various sublanguages of the
{\pic}. Yoshida's theory, however, is not a purely applicative
structure. The combinators must be connected using the {\pic}
operators for name creation and replication. As such, it is not
directly comparable to combinatorial accounts of other calculi, nor
does it serve, directly, as a basis for a machine representation.

The reflective approach eliminates the need for explicit operators for
name creation and replication. These are defined operations in the
reflective theory. As a result, it appears to have, much like the
{$\lambda$-calculus}'s \textsf{SKI} algebra \cite{BarendregtLambda}, a
purely applicative combinatorial presentation. Such an algebra has
important theoretical implications, especially in light of Yoshida's
expressiveness results. But, as has long been recognized, these kinds
of combinatorial presentations provide a framework for a machine-based
representation (cf. the categorical abstract machine,
\cite{CousineauCurienCAM}).

\paragraph{Stochastic interpretation} 

As noted in \cite{priamimolecularprocesses}, to model biological systems a stochastic
semantics seems necessary. We propose to extend the basic theory with
the stochastic semantics along the lines of \cite{priamistochasticpi}. While it is not
expected to yield any theoretical surprises, it is a necessary
development for the applications in mind.

\paragraph{Denotational semantics} 

The work has been developed with an ambient domain in mind, based on
earlier work with Abramsky on a functor category semantics for {\pic}
based on the category of non-well-founded sets. The reflective
structure, surprisingly, simplifies much of the categorical machinery
needed to model the dynamics of the algebra. Again, providing such an
account is of theoretical interest because it brings a mobile process
algebra within the aegis of standard techniques for program logics. \cite{AbramskyDTLF}

\subsection{Applications}

\paragraph{Case study: Signal pathways I} 

In her ground-breaking work, Aviv Regev has demonstrated the efficacy
of the {\pic} for modeling biochemical signal pathways
\cite{RegevMolecularPathwaysPi}. A first step in studying the efficacy
of this reflective framework in biological applications is to check
that existing work can be treated with equal facility. We propose to
recap some of the work done by Regev and her collaborators.

\paragraph{Case study: Signal pathways II} 

Under the optimistic presumption that such a study turns out
positively, it is proposed to extend the study to account for some of
the phenomena associated with the extension of sites. Folding, hiding
and partial matching all seem natural phenomena to approach.

\subsection{Implementation}

\paragraph{Virtual machine} 

As with other mobile process algebras, the operational semantics of
this reflective system provides the basis for a virtual machine. The
goal of this sub-project is to provide another check of the soundness
of the approach: implement the virtual machine implicit in the
semantics.

\paragraph{Combinator-based instruction set} 

As mentioned above, the combinator-based approach suggests a machine
representation. This in turn suggests a novel hardware
architecture. We propose to develop a compiler from the combinator
representation to VHDL.

\section{Timeline}

We propose a three year investigation divided into segments of theory,
applications and implementation.

\subsection{Year 1: Theory}

In the first year, we propose to fully develop the operational and
denotational accounts. 

\paragraph{Deliverables}

\begin{description}
	\item [operational semantics] Two conference papers.
	\item [combinators] One conference paper.
	\item [stochastic semantics] One conference paper.
	\item [denotational semantics] One journal paper.
\end{description}

\subsection{Year 2: Applications}

In the next year we propose to execute the case studies for the
applicability of the reflective approach to modeling biological systems.

\paragraph{Deliverables}

\begin{description}
	\item [relationship to existing approaches] One conference paper.
	\item [extension with sites] One or two conference papers.
\end{description}

\subsection{Year 3: Implementation}

In the final year we propose to provide convincing evidence of the
viability of this approach through a prototype of the virtual machine
implicit in the operational semantics. The expectation is to deliver a
public domain reference implementation to the community of
researchers.

Additionally, the combinator-based approach indicates a novel hardware
architecture. We propose to provide a public domain reference
implementation of a compiler from the machine-representation derived
from the combinators to VHDL.

\section{Collaboration}

\subsection{Imperial College}

Nobuko Yoshida has indicated some interest in the combinator-based
outline above. We hope to be able to collaborate with her in the first
phase of the project.

\subsection{Harvard System Biology}

Walter Fontana has indicated strong interest in the reflective
approach and has expressed his commitment to collaborate on this
approach.

\section{Budget}

\subsection{Equipment and materials}
	
	\paragraph{Machines}
	\paragraph{Office}
	\paragraph{Administrative support}

\subsection{Travel}

	\paragraph{Conferences}
	\paragraph{Visits with collaborators}

\paragraph{Acknowledgments.}
The author thanks Corrado Priami for his persistent prompting to get
the proposal together.

% ------------------------------------------------------------------------
%GATHER{Xbib.bib}   % For Gather Purpose Only
%GATHER{Paper.bbl}  % For Gather Purpose Only
\bibliographystyle{amsplain}
\bibliography{trento_research_proposal}

% ------------------------------------------------------------------------

\section{Appendix}

\subsection{Reflective asynchronous {\pic}}

We distinguish between syntactic categories and elements
thereof. Thus, $\category{P}$ denotes a syntactic category, while $P$
is an element of that category.

\begin{grammar}
\mbox{\rhoc}		& \category{P}			& \bc	& \pzero \\
				&					& \bm	& \category{x}\id{[}\category{x}\id{]} \\
				&					& \bm	& \category{x}\id{(}\category{x}\id{)} \concat \category{P} \\
				&					& \bm	& \lift{\category{x}}{\category{P}} \\
				&					& \bm	& \category{P} \juxtap \category{P} \\
				&					& \bm	& \dropn{\category{x}} \\
				& \category{x}  		& \bc	& \quotep{\category{P}}
\end{grammar}

\subsection{Free and bound names}

The syntax has been carefully chosen so that a bindging occurrence of
a name is sandwiched between round braces. Thus, the calculation of
the free names of a process, $P$, denoted $\freenames{P}$ is given
recursively by

%\begin{multicols}{2}
%{
	\begin{eqnarray*}
		\freenames{\pzero} & = & \emptyset \\
		\freenames{x \id{[}y\id{]}} & = & \{ x, y \} \\
		\freenames{x \id{(}y\id{)} \concat P} & = & \{ x \} \cup (\freenames{P} \setminus \{ y \}) \\
		\freenames{\lift{x}{P}} & = & \{ x \} \cup \freenames{P} \\
		\freenames{\binpar{P}{Q}} & = & \freenames{P} \cup \freenames{Q} \\
		\freenames{\dropn{x}} & = & \{ x \} \\
	\end{eqnarray*}
%}
%\end{multicols}

\subsection{Structural congruence}

The {\em structural congruence} of processes, noted $\scong$, is the
least congruence, containing $\alphaeq$ that satisfies the following
laws:

\begin{eqnarray*}
	\category{P} \juxtap \pzero	
		&  \scong \; \category{P} \; \scong & 
			\pzero \juxtap \category{P} \\
	\category{P}_0 \juxtap \category{P}_1	
		& \scong & 
			\category{P}_1 \juxtap \category{P}_0 \\
	(\category{P}_0 \juxtap \category{P}_1) \juxtap \category{P}_2	
		& \scong & 
			\category{P}_0 \juxtap (\category{P}_1 \juxtap \category{P}_2) \\
\end{eqnarray*}

\subsection{Name equivalence}

we must first equip our names with a theory of equality. We take this
to be the smallest equivalence relation generated by the following
rules.

\infrule[Quote-drop]
{  }
{ \quotep{\dropn{x}} \nameeq x }

\infrule[Struct-equiv]
{ P \scong Q }
{ \quotep{P} \nameeq \quotep{Q} }

\subsection{Substitution}

As is standard we use $P\id{\{}\vec{x_1} / \vec{x_0} \id{\}}$ to
denote capture-avoiding substitution of the names $\vec{x_1}$ for the
names $\vec{x_0}$. But, some care must be taken regarding
substitutions and quoted processes, i.e. $\quotep{P}$. 

Now, let $\Proc$ denote the set of processes and
$\QProc$ denote the set of names. Then, substitutions
are defined as partial maps, $s : \QProc \rightarrow \QProc$. These lift, uniquely, to maps $\dropn{s} :
\Proc \rightarrow \Proc$ by the following equations.

\begin{eqnarray*}
(0) \psubstp{Q}{P}         & = &    0 \\
(R \juxtap S) \psubstp{Q}{P}
		& = &    
		(R)\psubstp{Q}{P} \juxtap (S) \psubstp{Q}{P} \\
(x \id{(} y\id{)}\concat R) \psubstp{Q}{P}    
		& = &    
		(x)\substp{Q}{P} \id{(}z\id{)}\concat( (R \psubstn{z}{y}) \psubstp{Q}{P} ) \\
(x\id{[}y\id{]}) \psubstp{Q}{P}
		& = &    
		(x)\substp{Q}{P} \id{[}(y)\substp{Q}{P} \id{]} \\
(\lift{x}{R}) \psubstp{Q}{P}  
 		& = &
 		\lift{(x)\substp{Q}{P}}{ R \psubstp{Q}{P} } \\
(\dropn{x})  \psubstp{Q}{P}       
		& = & 
		\left\{ 
			\begin{array}{ccc} 
				Q & & x \nameeq \quotep{P} \\
                              	\dropn{x} & & otherwise \\
			\end{array}
		\right.
\end{eqnarray*}
 

where

\begin{equation*}
(x)\id{\{} \lpquote Q \rpquote / \lpquote P \rpquote \id{\}}            = 
		\left\{ 
			\begin{array}{ccc}
				\lpquote Q \rpquote & & x \nameeq \lpquote P \rpquote \\
                                x & & otherwise \\
			\end{array}
		\right.
\end{equation*}

and $z$ is chosen distinct from $\quotep{P}$, $\quotep{Q}$, the free
names in $Q$, and all the names in $R$.

Anticipating something of what's to come, these definitions should
make it clear that there is a significant difference between
$\lift{x}{P}$ and
$x\id{[}\lpquote P \rpquote\id{]}$. Specifically, consider the following pair of processes:

\begin{eqnarray*}
	\lift{w}{y \id{[}z\id{]}}\dropn{\id{\{}u / z \id{\}}}
		& = &
		\lift{w}{y \id{[}u\id{]}} \\
	w\id{[} \lpquote y\id{[}z\id{]} \rpquote \id{]} \rpquote \id{\{}u / z \id{\}} \lpquote
		& = &
		w\id{[} \lpquote y\id{[}z\id{]} \rpquote \id{]}
\end{eqnarray*}

Thus, the lift operator will be seen as a way to dynamically
construct processes before reifying them as names.

\begin{rem}
	Note that the substitution for alpha-equivalence, which -- by
	abuse of notation -- we write $\category{P}
	\substn{\category{x}_0}{\category{x}_1}$, will use name
	equivalence in its tests, but will not perform the drop. That
	is, its definition is identical to the one above, except for
	the following case.
\begin{equation*}
	(\dropn{x}) \substn{Q}{P}       
		= 
		\left\{ 
			\begin{array}{ccc} 
				\quotep{Q} & & x \nameeq \quotep{P} \\
                              	\dropn{x} & & otherwise \\
			\end{array}
		\right.	
\end{equation*}
\end{rem}

\begin{rem}
	The astute reader will have noticed that substitution is
	mutually recursive with $\nameeq$ and $\scong$. In particular,
	to carry out a substitution may require that one check the
	equivalence of two names. This may require that one check
	whether the processes they quote are structurally
	equivalent. This may require that one check that they are
	alpha-convertible. This, in turn, may require that one carry
	out a substitution!
	
	This does not present a problem, however, because each time
	around the circuit the names are getting strictly
	simpler. Ultimately, this recursion bottoms out in being able
	to check that $\pzero$ is the same as or structurally
	equivalent to $\pzero$. In other words, the mutual recursion
	is well-founded.
	
	Having observed the mutual recursion, however, it is now convenient to
	add one more structural equivalence law.
\end{rem}

\begin{eqnarray*}
 \category{P} \equiv \category{P} \substn{\category{x}_0}{\category{x}_1}, \; \mbox{\textit{if} }\category{x}_0 \nameeq \category{x}_1
\end{eqnarray*}

\subsection{Operational Semantics}
The reduction rules for {\rhoc}  are
% \infrule[Comm]
% { {\category{x}_0 \nameeq \category{x}_3} }
% {{{\category{x}_{0}\id{[}\category{x}_{2}\id{]}}} \juxtap {\category{x}_{3}\id{(}\category{x}_{1}\id{)} \concat \category{P}}
% \red \category{P}\id{\{}\category{x}_{2} \id{/} \category{x}_{1} \id{\}}}

\infrule[Comm]
{  }
{{{\category{x}_{0}\id{[}\category{x}_{2}\id{]}}} \juxtap {\category{x}_{0}\id{(}\category{x}_{1}\id{)} \concat \category{P}}
\red \category{P}\id{\{}\category{x}_{2} \id{/} \category{x}_{1} \id{\}}}

\infrule[Lift]
{  }
{{\lift{\category{x}}{\category{P}}}
\red \category{x}\id{[}\lpquote\category{P}\rpquote\id{]}}

In addition, we have the following context rules:

\infrule[Par]{\category{P}_0 \red \category{P}_1}{{\category{P}_0 \juxtap \category{P}_2} \red {\category{P}_1 \juxtap \category{P}_2}}

\infrule[Equiv]{{\category{P}_2 \scong \category{P}_0} \andalso {\category{P}_0 \red \category{P}_1} \andalso {\category{P}_1 \scong \category{P}_3}}{\category{P}_2 \red \category{P}_3}

% ------------------------------------------------------------------------

\end{document}
% ------------------------------------------------------------------------
