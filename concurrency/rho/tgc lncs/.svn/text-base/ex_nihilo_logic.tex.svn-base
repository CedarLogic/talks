% ------------------------------------------------------------------------
% LNCS LaTeX Paper ******************************************************
% ------------------------------------------------------------------------
% Submitted:      July 12 2005
% Final Version:  
% Accepted:       
% ------------------------------------------------------------------------
% This is a journal top-matter template file for use with AMS-LaTeX.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\documentclass{tran-l}
%\documentclass[twocolumn]{amsart}
%\documentclass[]{amsart}
\documentclass[]{llncs}

%\documentclass[]{entcs}
%\usepackage[]{prentcsmacro}

%\usepackage[active]{srcltx} % SRC Specials for DVI Searching
\usepackage{url}

% From Allen's stable.
%\usepackage{bigpage}
\usepackage{bcprules}
\usepackage{code}
\usepackage{amsfonts}
\usepackage{latexsym}
\usepackage{amssymb}
%\usepackage{caption}
\usepackage{multicol}

% Double brackets
\newcommand{\ldb}{[\![}
\newcommand{\rdb}{]\!]}
\newcommand{\ldrb}{(\!(}
\newcommand{\rdrb}{)\!)}
\newcommand{\lliftb}{\langle\!|}
\newcommand{\rliftb}{|\!\rangle}
% \newcommand{\lpquote}{\langle}
% \newcommand{\rpquote}{\rangle}
% \newcommand{\lpquote}{\lceil}
% \newcommand{\rpquote}{\rceil}
\newcommand{\lpquote}{\ulcorner}
\newcommand{\rpquote}{\urcorner}
\newcommand{\newkw}{\nu}

% SYNTAX
\newcommand{\id}[1]{\texttt{#1}}
\newcommand{\none}{\emptyset}
\newcommand{\eps}{\epsilon}
\newcommand{\set}[1]{\{#1\}}
\newcommand{\rep}[2]{\id{\{$#1$,$#2$\}}}
\newcommand{\elt}[2]{\id{$#1$[$#2$]}}
\newcommand{\infinity}{$\infty$}

\newcommand{\pzero}{\mathbin{0}}
\newcommand{\seq}{\mathbin{\id{,}}}
\newcommand{\all}{\mathbin{\id{\&}}}
\newcommand{\choice}{\mathbin{\id{|}}}
\newcommand{\altern}{\mathbin{\id{+}}}
\newcommand{\juxtap}{\mathbin{\id{|}}}
\newcommand{\concat}{\mathbin{.}}
\newcommand{\punify}{\mathbin{\id{:=:}}}
\newcommand{\fuse}{\mathbin{\id{=}}}
\newcommand{\scong}{\mathbin{\equiv}}
\newcommand{\nameeq}{\mathbin{\equiv_N}}
\newcommand{\alphaeq}{\mathbin{\equiv_{\alpha}}}
\newcommand{\names}[1]{\mathbin{\mathcal{N}(#1)}}
\newcommand{\freenames}[1]{\mathbin{\mathcal{FN}(#1)}}
\newcommand{\boundnames}[1]{\mathbin{\mathcal{BN}(#1)}}
%\newcommand{\lift}[2]{\texttt{lift} \; #1 \concat #2}
\newcommand{\binpar}[2]{#1 \juxtap #2}
\newcommand{\outputp}[2]{#1 \id{[} #2 \id{]}}
\newcommand{\prefix}[3]{#1 \id{(} #2 \id{)} \concat #3}
\newcommand{\lift}[2]{#1 \lliftb #2 \rliftb}
\newcommand{\quotep}[1]{\lpquote #1 \rpquote}
\newcommand{\dropn}[1]{\rpquote #1 \lpquote}

\newcommand{\newp}[2]{\id{(}\newkw \; #1 \id{)} #2}
\newcommand{\bangp}[1]{\id{!} #1}

\newcommand{\substp}[2]{\id{\{} \quotep{#1} / \quotep{#2} \id{\}}}
\newcommand{\substn}[2]{\id{\{} #1 / #2 \id{\}}}

\newcommand{\psubstp}[2]{\widehat{\substp{#1}{#2}}}
\newcommand{\psubstn}[2]{\widehat{\substn{#1}{#2}}}

\newcommand{\applyp}[2]{#1 \langle #2 \rangle}
\newcommand{\absp}[2]{\id{(} #1 \id{)} #2}

\newcommand{\transitions}[3]{\mathbin{#1 \stackrel{#2}{\longrightarrow} #3}}
\newcommand{\meaningof}[1]{\ldb #1 \rdb}
\newcommand{\pmeaningof}[1]{\ldb #1 \rdb}
\newcommand{\nmeaningof}[1]{\ldrb #1 \rdrb}

\newcommand{\Proc}{\mathbin{Proc}}
\newcommand{\QProc}{\quotep{\mathbin{Proc}}}

\newcommand{\entailm}{\mathbin{\vdash_{\mathfrak m}}} %matching
\newcommand{\entailp}{\mathbin{\vdash_{\mathfrak p}}} %behavioral
\newcommand{\entailv}{\mathbin{\vdash_{\mathfrak v}}} %validation
\newcommand{\congd}{\mathbin{\equiv_{\mathfrak d}}}
\newcommand{\congs}{\mathbin{\equiv_{\mathfrak s}}}
\newcommand{\congp}{\mathbin{\equiv_{\mathfrak p}}}
%\newcommand{\logequiv}{\mathbin{\leftrightarrow}}

\newcommand{\barb}[2]{\mathbin{#1 \downarrow_{#2}}}
\newcommand{\dbarb}[2]{\mathbin{#1 \Downarrow_{#2}}}

% From pi-duce paper
\newcommand{\red}{\rightarrow}
\newcommand{\wred}{\Rightarrow}
\newcommand{\redhat}{\hat{\longrightarrow}}
\newcommand{\lred}[1]{\stackrel{#1}{\longrightarrow}} %transitions
\newcommand{\wlred}[1]{\stackrel{#1}{\Longrightarrow}}

\newcommand{\opm}[2]{\overline{#1} [ #2 ]} % monadic
\newcommand{\ipm}[2]{{#1} ( #2 )} 
\newcommand{\ipmv}[2]{{#1} ( #2 )} % monadic
\newcommand{\parop}{\;|\;}		% parallel operator
\newcommand{\patmatch}[3]{#2 \in #3 \Rightarrow #1}
\newcommand{\sdot}{\, . \,}		% Space around '.'
\newcommand{\bang}{!\,}
%\newcommand{\fuse}[1]{\langle #1 \rangle}		
\newcommand{\fusion}[2]{#1 = #2} % fusion prefix/action
\newcommand{\rec}[2]{\mbox{\textsf{rec}} \, #1. \, #2}
\newcommand{\match}[2]{\mbox{\textsf{match}} \; #1 \; \mbox{\textsf{with}} \; #2}
\newcommand{\sep}{:}
\newcommand{\val}[2]{\mbox{\textsf{val}} \; #1 \; \mbox{\textsf{as}} \; #2}

\newcommand{\rel}[1]{\;{\mathcal #1}\;} %relation
\newcommand{\bisim}{\stackrel{.}{\sim}_b} %bisimilar
\newcommand{\wb}{\approx_b} %weak bisimilar
\newcommand{\bbisim}{\stackrel{\centerdot}{\sim}} %barbed bisimilar
\newcommand{\wbbisim}{\stackrel{\centerdot}{\approx}} %weak barbed bisimilar
\newcommand{\bxless}{\lesssim}	%expansion less (amssymb required)
\newcommand{\bxgtr}{\gtrsim}	%expansion greater (amssymb required)
\newcommand{\beq}{\sim}		%barbed congruent
\newcommand{\fwbeq}{\stackrel{\circ}{\approx}}	%weak barbed congruent
\newcommand{\wbeq}{\approx}	%weak barbed congruent
\newcommand{\sheq}{\simeq}	%symbolic hypereq
\newcommand{\wbc}{\approx_{cb}}

% rho logic

\newcommand{\ptrue}{\mathbin{true}}
\newcommand{\psatisfies}[2]{#1 \models #2}
\newcommand{\pdropf}[1]{\rpquote #1 \lpquote}
\newcommand{\plift}[2]{#1 \lliftb #2 \rliftb}
\newcommand{\pprefix}[3]{\langle #1 ? #2 \rangle #3}
\newcommand{\pgfp}[2]{\textsf{rec} \; #1 \mathbin{.} #2}
\newcommand{\pquant}[3]{\forall #1 \mathbin{:} #2 \mathbin{.} #3}
\newcommand{\pquantuntyped}[2]{\forall #1 \mathbin{.} #2}
\newcommand{\riff}{\Leftrightarrow}

\newcommand{\PFormula}{\mathbin{PForm}}
\newcommand{\QFormula}{\mathbin{QForm}}
\newcommand{\PropVar}{\mathbin{\mathcal{V}}}

% End piduce contribution

\newcommand{\typedby}{\mathbin{\:\colon}}
\newcommand{\mixedgroup}[1]{\id{mixed($#1$)}}
\newcommand{\cast}[2]{\id{CAST AS} \; #1 \; (#2)}
\newcommand{\bslsh}{\mathbin{\id{\\}}}
\newcommand{\bslshslsh}{\mathbin{\id{\\\\}}}
\newcommand{\fslsh}{\mathbin{\id{/}}}
\newcommand{\fslshslsh}{\mathbin{\id{//}}}
\newcommand{\bb}[1]{\mbox{#1}}
\newcommand{\bc}{\mathbin{\mathbf{::=}}}
\newcommand{\bm}{\mathbin{\mathbf\mid}}
\newcommand{\be}{\mathbin{=}}
\newcommand{\bd}{\mathbin{\buildrel {\rm \scriptscriptstyle def} \over \be}}
\newcommand{\category}[1]{\mbox{\bf #1}}

%GRAMMAR
\newlength{\ltext}
\newlength{\lmath}
\newlength{\cmath}
\newlength{\rmath}
\newlength{\rtext}

\settowidth{\ltext}{complex type name}
\settowidth{\lmath}{$xxx$}
\settowidth{\cmath}{$::=$}
\settowidth{\rmath}{\id{attributeGroup}}
\settowidth{\rtext}{repetition of $g$ between $m$ and $n$ times}

\newenvironment{grammar}{
  \[
  \begin{array}{l@{\quad}rcl@{\quad}l}
  \hspace{\ltext} & \hspace{\lmath} & \hspace{\cmath} & \hspace{\rmath} & \hspace{\rtext} \\
}{
  \end{array}\]
}

% Over-full v-boxes on even pages are due to the \v{c} in author's name
%\vfuzz2pt % Don't report over-full v-boxes if over-edge is small

% THEOREM Environments ---------------------------------------------------
% MATH -------------------------------------------------------------------
 \newcommand{\veps}{\varepsilon}
 \newcommand{\To}{\longrightarrow}
 \newcommand{\h}{\mathcal{H}}
 \newcommand{\s}{\mathcal{S}}
 \newcommand{\A}{\mathcal{A}}
 \newcommand{\J}{\mathcal{J}}
 \newcommand{\M}{\mathcal{M}}
 \newcommand{\W}{\mathcal{W}}
 \newcommand{\X}{\mathcal{X}}
 \newcommand{\BOP}{\mathbf{B}}
 \newcommand{\BH}{\mathbf{B}(\mathcal{H})}
 \newcommand{\KH}{\mathcal{K}(\mathcal{H})}
 \newcommand{\Real}{\mathbb{R}}
 \newcommand{\Complex}{\mathbb{C}}
 \newcommand{\Field}{\mathbb{F}}
 \newcommand{\RPlus}{\Real^{+}}
 \newcommand{\Polar}{\mathcal{P}_{\s}}
 \newcommand{\Poly}{\mathcal{P}(E)}
 \newcommand{\EssD}{\mathcal{D}}
 \newcommand{\Lom}{\mathcal{L}}
 \newcommand{\States}{\mathcal{T}}
 \newcommand{\abs}[1]{\left\vert#1\right\vert}
% \newcommand{\set}[1]{\left\{#1\right\}}
%\newcommand{\seq}[1]{\left<#1\right>}
 \newcommand{\norm}[1]{\left\Vert#1\right\Vert}
 \newcommand{\essnorm}[1]{\norm{#1}_{\ess}}

%%% NAMES
\newcommand{\Names}{{\mathcal N}}
\newcommand{\Channels}{{\sf X}}
\newcommand{\Variables}{{\mathcal V}}
\newcommand{\Enames}{{\mathcal E}}
\newcommand{\Nonterminals}{{\mathcal S}}
\newcommand{\Pnames}{{\mathcal P}}
\newcommand{\Dnames}{{\mathcal D}}
\newcommand{\Types}{{\mathcal T}}

\newcommand{\fcalc}{fusion calculus}
\newcommand{\xcalc}{${\mathfrak x}$-calculus}
\newcommand{\lcalc}{$\lambda$-calculus}
\newcommand{\pic}{$\pi$-calculus}
\newcommand{\spic}{spi-calculus}
\newcommand{\rhoc}{$\rho$-calculus}
\newcommand{\rhol}{$\rho$-logic}
\newcommand{\hcalc}{highwire calculus}
\newcommand{\dcalc}{data calculus}
%XML should be all caps, not small caps. --cb
%\newcommand{\xml}{\textsc{xml}}
\newcommand{\xml}{XML} 

\newcommand{\papertitle}{A logic for a reflective higher-order calculus}
% use static date to preserve date of actual publication
\newcommand{\paperversion}{Draft Version 0.1 - December 19, 2004}

\newenvironment{toc}
{
\begin{list}{}{
   \setlength{\leftmargin}{0.4in}
   \setlength{\rightmargin}{0.6in}
   \setlength{\parskip}{0pt}
 } \item }
{\end{list}}

\newenvironment{narrow}
{
\begin{list}{}{
   \setlength{\leftmargin}{0.4in}
   \setlength{\rightmargin}{0.6in}
 } \item }
{\end{list}}

\def\lastname{Meredith and Radestock}
%%% ----------------------------------------------------------------------
\begin{document}

%\begin{frontmatter}
\title{Namespace logic: A logic for a reflective higher-order calculus}
\titlerunning{Namespace logic}

\author{ L.G. Meredith\inst{1} \and Matthias Radestock\inst{2} }
\institute{ CTO, Djinnisys Corporation\\ 505 N72nd St, Seattle, WA 98103, USA, \\
  \email{ lgreg.meredith@gmail.com } \\
  \and CTO, LShift, Ltd.\\ 6 Rufus St, London N1 6PE, UK \\
  \email{ matthias@lshift.net }
}		

\maketitle              % typeset the title of the contribution

%%% ----------------------------------------------------------------------

	\begin{abstract}

          In \cite{meredith2005rho} it was observed that a theory like
          the {\pic}, dependent on a theory of names, can be closed,
          through a mechanism of quoting, so that (quoted) processes
          provide the necessary notion of names. Here we expand on
          this theme by examining a construction for a Hennessy-Milner
          logic corresponding to an asynchronous message-passing
          calculus built on a notion of quoting.

          Like standard Hennessy-Milner logics, the logic exhibits
          formulae corresponding to sets of processes, but a new class
          of formulae, corresponding to sets of names, also
          emerges. This feature provides for a number of interesting
          possible applications from security to data
          manipulation. Specifically, we illustrate formulae for
          controlling process response on ranges of names reminiscent
          of a (static) constraint on port access in a firewall
          configuration. Likewise, we exhibit formulae in a
          names-as-data paradigm corresponding to validation for
          fragment of \texttt{XML Schema}.

	\end{abstract}

% 	\begin{keyword}
% 		concurrency, message-passing, process calculus, reflection, program logic
% 	\end{keyword}

%\end{frontmatter}

\section{Introduction}

Starting from the practical end of things, whether we consider MAC
addresses, IP addresses, domain names or URL's it is clear that
distributed computing is practiced, today, using names. Moreover, it
is essential to the programs that administer as well as to the ones
that compute over this distributed computing infrastructure that these
names have structure. Thus, when we look to theory, especially a
theory, like the {\pic}, of computing based on interaction over named
channels, to help us with this practice some story must be told about
how the structure of these names contributes to interaction and
computation over (channels named by) them.

Starting from the theoretical end, nowhere in the tools available to
the computer scientist is there a countably infinite set of
\textit{atomic} entities that might function as names. All such sets,
e.g. the natural numbers, the set of strings of finite length on some
alphabet, etc., are \textit{generated} from a finite presentation, and
as such the elements of these sets inherit \textit{structure} from the
generating procedure. As a theoretician focusing on some aspects of
the theory of processes built from such a set, one may temporarily
forget that structure, but it is there nonetheless, and comes to the
fore the moment one tries to build \textit{executable} models of these
calculi.

Thus the fact that the {\pic} (\cite{milner91polyadicpi}) is not a
closed theory, but rather a theory dependent upon some theory of names
is both enabling and limiting. This openness of the theory has been
exploited, for example, in {\pic} implementations, like the execution
engine in Microsoft's Biztalk \cite{biztalk}, where an ancillary
binding language providing a means of specifying a `theory' of names;
e.g., names may be tcp/ip ports or urls or object references,
etc. Reasoning foundationally, however, when names have structure,
name equality becomes a computation; but, if our theory of interaction
is to provide a basis for a theory of computation -- especially of
\emph{distributed} computation -- then certainly this computation must be
accounted for as well. Moreover, the fact that any realization of
these name-based, mobile calculi of interaction must come to grips
with names that have structure begs the question: would the
theoretical account of interaction be more effective, both as a theory
in its own right and as a guide for implementation, if it included an
account of the relationships between the structure of names and the
structure of processes?

\subsection{Overview and contributions} 

In \cite{meredith2005rho} we presented a theory of an asynchronous
message-passing calculus built on a notion of quoting in which names
have the structure of quoted processes, and may be thought of as
representing the code of some process, i.e. a reification of the
syntactic structure of some process (up to some
equivalence). Name-passing, as such, becomes a way of passing the code
of a process as a message, and in the presence of a dequote operation,
turning the code of a process into a running instance, this machinery
yields higher-order characteristics without the introduction of
process variables. \footnote{Following the tradition started by Smith
  and des Rivieres, \cite{lisp3} we dubbed this ability to turn
  running code into data and back again, reflection; and hence, called
  the calculus the \textit{r}eflective, \textit{h}igher-\textit{o}rder
  calculus, or rho-calculus, for short, or $\rho$-calculus for even
  shorter.} As is standard with higher-order calculi, replication
and/or recursion is no longer required as a primitive
operation. Somewhat more interestingly, the introduction of a process
constructor to dynamically convert a process into its code is
essential to obtain computational completeness, and simultaneously
supplants the function of the $\nu$ operator. \footnote{In fact,
  \cite{meredith2005rho} gives a compositional encoding of the $\nu$
  operator into the calculus, making essential use of dynamic quote as
  well as dequote.}

In this paper we take the idea a little further via an investigation
of a Hennessy-Milner logic for this calculus. The logic is a form of
spatial logic (\cite{DBLP:journals/iandc/CairesC03},
\cite{DBLP:journals/tcs/CairesC04}) with operators detecting
structural as well as behavioral content of process. Further, like
many other logics for message-passing calculi it describes formulae
denoting sets of such processes in a more or less standard manner, but
the additional reflective structure on names also gives rise to a new
class of formulae. These formulae denote sets of \emph{names},
referred to in the sequel as namespaces and causing us to dub the
logic \emph{namespace logic}.

These new formulae suggest approaches to various application domains,
e.g. reasoning about security, or the structure of the data passed
between processes, that differ somewhat from the current treatment of
these domains using message-passing calculi. For example, the analytic
framework was not designed with security in mind, and as such has no
additional security-specific features like nonce construction or
unpacking, as is found in Gordon's {\spic}
(\cite{DBLP:conf/ccs/AbadiG97}), and yet has very simple formulae to
express such properties as that a process will only ever receive
requests from a given range of ports. Moreover, these properties are
expressed as \emph{formulae}, not as process specifications, thus
observance is measured by satisfaction not protocol
equivalence. Further, while closer in spirit -- ala the
proposition-as-types paradigm -- to type-based approaches like Gordon
and Jeffrey's approach to typing correspondence assertions
\cite{DBLP:journals/tcs/GordonJ03} or Abadi's various type systems for
security (\cite{DBLP:journals/tcs/AbadiB03}
\cite{DBLP:conf/popl/AbadiB02}), it is a logic and not a type system
with the attendent advantages and disadvantages. For example, a very
broad range of properties may be expressed, but the system is only
semi-decidable. Likewise, neither the calculus nor the logic were
designed with any particular data analysis in mind, and yet we find
relatively simple treatment of the semantics of validation for a
fragment of \texttt{XML} schema.

While the main focus of the paper is the logic, and some suggestive
examples, to provide a self-contained presentation, the paper also
presents a concrete instance of a minimal reflective asynchronous
message-passing calculus and the manner in which its processes and
names witness the formulae of the logic. As in \cite{meredith2005rho} where we
took the view that the main contribution of the concrete machinery was to
provide an instrument to bring to life a set of questions regarding
the role of names in calculi of interaction, here we assert
that the real contribution manifest by the logic is an instrument to
better frame and sharpen those questions. These questions include the
calculation of name equality as a computation to be considered within
the framework of interaction and the roles of name equality in
substitution versus synchronization. These questions don't really come
to life, though, without the instruments in hand. So, we turn
immediately to the formal presentation.

%%% ----------------------------------------------------------------------

\section{The calculus}

This presentation is essentially the same as the one found in \cite{meredith2005rho}.

\subsubsection{Notation}

We let ${P, Q, R}$ range over processes and ${x, y, z}$ range over names.

\begin{grammar}
\mbox{\rhoc}		& {P, Q}		& \bc	& \pzero & \mbox{null process} \\
%				&					& \bm	& {x}\id{[}{y}\id{]} & \mbox{output} \\
				&					& \bm	& {x}\id{(}{y}\id{)} \concat {P} & \mbox{input} \\
				&					& \bm	& \lift{{x}}{{P}} & \mbox{lift} \\
				&					& \bm	& \dropn{{x}} & \mbox{ drop } \\
				&					& \bm	& {P} \juxtap {Q} & \mbox{ parallel } \\
				& {x, y}  		& \bc	& \quotep{{P}} & \mbox{ quote } \\
\end{grammar}

\subsubsection{Quote}

Working in a bottom-up fashion, we begin with names. The technical
detail corresponding to the {\pic}' parametricity in a theory of
\textit{names} shows up in standard presentations in the grammar
describing terms of the language: there is no production for names;
names are taken to be terminals in the grammar. Our first point of
departure from a more standard presentation of an asynchronous mobile
process calculus is here. The grammar for the terms of the language
will include a production for names in the grammar. A name is a
\textit{quoted} process, $\quotep{P}$.

\subsubsection{Parallel}

This constructor is the usual parallel composition, denoting
concurrent execution of the composed processes.

\subsubsection{Lift and drop}
Despite the fact that names are built from (the codes of) processes,
we still maintain a careful disinction in kind between process and
name; thus, name construction is not process construction. So, if one
wants to be able to generate a name from a given process, there must
be a process constructor for a term that creates a name from a
process. This is the motivation for the production $\lift{x}{P}$,
dubbed here the \emph{lift} operator. The intuitive meaning of this
term is that the process $P$ will be packaged up as its code,
$\quotep{P}$, and ultimately made available as an output at the port
$x$.

A more formal motivation for the introduction of this operator will
become clear in the sequel. But, it will suffice to say now that
$\quotep{P}$ is impervious to substitution. In the $\rho$-calculus,
substitution does not affect the process body between quote marks. On
the other hand, $\lift{x}{P}$ is susceptible to substitution and as
such constitutes a dynamic form of quoting because the process body
ultimately quoted will be different depending on the context in which
the $\lift{x}{P}$ expression occurs.

Of course, when a name is a quoted process, it is very handy to have a
way of evaluating such an entity. Thus, the $\dropn{x}$ operator,
pronounced \textit{drop} $x$, (eventually) extracts the process from a
name. We say `eventually' because this extraction only happens when a
quoted process is substituted into this expression. A consequence of
this behavior is that $\dropn{x}$ is inert except under and input
prefix. One way of saying this is that if you want to get something
done, sometimes you need to drop a name, but it should be the name of
an agent you know.

\begin{remark} %{No $\nu$ is good news}
The lift operator turns out to play a role analogous to $(\nu \;
x)P$. As mentioned in the introduction, it is essential to the
computational completeness of the calculus, playing a key role in the
implementation of replication. It also provides an essential
ingredient in the compositional encoding of the $\nu$ operator.
\end{remark}

\begin{remark} %{Dropping replication}
It is well-known that replication is not required in a higher-order
process algebra \cite{SangiorgiWalker}. While our algebra is
\textit{not} higher-order in the traditional sense (there are not
formal process variables of a different type from names) it has all
the features of a higher-order process algebra. Thus, it turns out
that there is no need for a term for recursion. To illustrate this we
present below an encoding of $!P$ in this calculus. Intuitively, this
will amount to receiving a quoted form of a process, evaluating it,
while making the quoted form available again. The reader familiar with
the $\lambda$-calculus will note the formal similarity between the
crucial term in the encoding and the paradoxical combinator
\cite{Barendregt84}.
\end{remark}

\subsubsection{Input and output}

The input constructor is standard for an asynchronous name-passing
calculus. Input blocks its continuation from execution until it
receives a communication. Lift is a form of output which -- because
the calculus is asynchronous -- is allowed no continuation. It also
affords a convenient syntactic sugar, which we define here.

\begin{eqnarray}
	{x}\id{[}{y}\id{]} \triangleq \lift{x}{\dropn{y}} \nonumber
\end{eqnarray}

\subsubsection{The null process}

As we will see below, the null process has a more distinguished role
in this calculus. It provides the sole atom out of which all other
processes (and the names they use) arise much in the same way that the
number $0$ is the sole number out of which the natural numbers are
constructed; or the empty set is the sole set out of which all sets
are built in $ZF$-set theory \cite{Krivine-TheCurryHowardCorre}; or
the empty game is the sole game out of which all games are built in
Conway's theory of games and numbers \cite{ONAG}. This analogy to
these other theories draws attention, in our opinion, to the
foundational issues raised in the introduction regarding the design of
calculi of interaction.

\subsection{The name game}

Before presenting some of the more standard features of a mobile
process calculus, the calculation of free names, structural
equivalence, etc., we wish to consider some examples of processes and
names. In particular, if processes are built out of names, and names
are built out of processes, is it ever possible to get off the ground?
Fortunately, there is one process the construction of which involves
no names, the null process, $0$. Since we have at least one process,
we can construct at least one name, namely $\quotep{0}$ \footnote{pun
gratefully accepted ;-)}. Armed with one name we can now construct at
least two new processes that are evidently syntactically different
from the $0$, these are $\quotep{0}\id{[}{\quotep{0}}\id{]}$ and
$\quotep{0}\id{(}{\quotep{0}}\id{)} \concat 0$. As we might expect,
the intuitive operational interpretation of these processes is also
distinct from the null process. Intuitively, we expect that the first
outputs the name $\quotep{0}$ on the channel $\quotep{0}$, much like
the ordinary {\pic} process $x\id{[}x\id{]}$ outputs the name $x$ on
the channel $x$, and the second inputs on the channel $\quotep{0}$,
much like the ordinary {\pic} process $x\id{(}x\id{)} \concat 0$
inputs on the channel $x$.

Of course, now that we have two more processes, we have two more
names, $\quotep{\quotep{0}\id{[}{\quotep{0}}\id{]}}$ and
$\quotep{\quotep{0}\id{(}{\quotep{0}}\id{)} \concat 0}$. Having three
names at our disposal we can construct a whole new supply of processes
that generate a fresh supply of names, and we're off and running. It
should be pointed out, though, that as soon as we had the null process
we also had $0 \juxtap 0$ and $0 \juxtap 0 \juxtap 0$ and
consequently, we had the names $\quotep{ 0 \juxtap 0 }$, and $\quotep{
0 \juxtap 0 \juxtap 0}$, and .... But, since we ultimately wish to
treat these compositions as merely other ways of writing the null
process and not distinct from it, should we admit the codes of these
processes as distinct from $\quotep{0}$?

This question leads to several intriguing and apparently fundamental
questions. Firstly, if names have structure, whether this derives from
the structure of processes or something else, what is a reasonable
notion of equality on names? How much computation, and of what kind,
should go into ascertaining equality on names? Additionally, what
roles should name equality play in a calculus of processes? In
constructing this calculus we became conscious that substitution and
synchronization identify two potentially very different roles for name
equality to play in name-passing calculi. That these are very
different roles is suggested by the fact that they may be carried out
by very different mechanisms in a workable and effective theory. We
offer one choice, but this is just one design choice among infinitely
many. Most likely, the primary value of this proposal is to raise the
question. Likewise, we offer a proposal regarding the calculation of
name equality that is just one of many and whose real purpose is to
make the question vivid. We wish to turn to the core mechanics of the
calculus with these questions in mind.

\subsection{Free and bound names}

The syntax has been chosen so that a binding occurrence of a name is
sandwiched between round braces, $\id{(} \cdot \id{)}$. Thus, the
calculation of the free names of a process, $P$, denoted
$\freenames{P}$ is given recursively by

%\begin{multicols}{2}
%{
	\begin{eqnarray}
		\freenames{\pzero} & = & \emptyset \nonumber\\
%		\freenames{x \id{[}y\id{]}} & = & \{ x, y \} \\
		\freenames{x \id{(}y\id{)} \concat P} & = & \{ x \} \cup (\freenames{P} \setminus \{ y \}) \nonumber\\
		\freenames{\lift{x}{P}} & = & \{ x \} \cup \freenames{P} \nonumber\\
		\freenames{\binpar{P}{Q}} & = & \freenames{P} \cup \freenames{Q} \nonumber\\
		\freenames{\dropn{x}} & = & \{ x \} \nonumber
	\end{eqnarray}
%}
%\end{multicols}

An occurrence of $x$ in a process $P$ is \textit{bound} if it is not
free. The set of names occurring in a process (bound or free) is
denoted by $\names{P}$.

\subsection{Structural congruence}

The {\em structural congruence} of processes, noted $\scong$, is the
least congruence, containing $\alpha$-equivalence, $\alphaeq$, that
satisfies the following laws:

\begin{eqnarray}
	{P} \juxtap \pzero	
		&  \scong \; {P} \; \scong & 
			\pzero \juxtap {P} \nonumber\\
	{P} \juxtap {Q}	
		& \scong & 
			{Q} \juxtap {P} \nonumber\\
	({P} \juxtap {Q}) \juxtap {R}
		& \scong & 
			{P} \juxtap ({Q} \juxtap {R}) \nonumber
\end{eqnarray}

\subsection{Name equivalence}

We now come to one of the first real subtleties of this calculus. Both
the calculation of the free names of a process and the determination
of structural congruence between processes critically depend on being
able to establish whether two names are equal. In the case of the
calculation of the free names of an input-guarded process, for
example, to remove the bound name we must determine whether it is in
the set of free names of the continuation. Likewise, structural
congruence includes $\alpha$-equivalence. But, establishing
$\alpha$-equivalence between the processes $x \id{(} z \id{)}\concat \lift{w}{y
\id{[}z\id{]}}$ and $x \id{(} v \id{)}\concat \lift{w}{y
\id{[}v\id{]}}$, for instance, requires calculating a substitution, e.g. $x \id{(} v \id{)}\concat \lift{w}{y
\id{[}v\id{]}} \id{\{}z / v \id{\}}$. But this calculation requires, in turn, being able to
determine whether two names, in this case the name in the object
position of the output, and the name being substituted for, are equal.

As will be seen, the equality on names involves structural equivalence
on processes, which in turn involves alpha equivalence, which involves
name equivalence. This is a subtle mutual recursion, but one that
turns out to be well-founded. Before presenting the technical details,
the reader may note that the grammar above enforces a strict
alternation between quotes and process constructors. Each question
about a process that involves a question about names may in turn
involve a question about processes, but the names in the processes the
next level down, as it were, are under fewer quotes. To put it another
way, each `recursive call' to name equivalence will involve one less
level of quoting, ultimately bottoming out in the quoted zero process.

Let us assume that we have an account of (syntactic) substitution and
$\alpha$-equivalence upon which we can rely to formulate a notion of
name equivalence, and then bootstrap our notions of substitution and
$\alpha$-equivalence from that. We take name equivalence, written
$\nameeq$, to be the smallest equivalence relation generated by the
following rules.


\infrule[Quote-drop]
{  }
{ \quotep{\dropn{x}} \nameeq x }

\infrule[Struct-equiv]
{ P \scong Q }
{ \quotep{P} \nameeq \quotep{Q} }

\subsection{Syntactic substitution}

Now we build the substitution used by $\alpha$-equivalence. We use
$\Proc$ for the set of processes, $\QProc$ for the set of names, and
$\id{\{}\vec{y} / \vec{x} \id{\}}$ to denote partial maps, $s : \QProc
\rightarrow \QProc$. A map, $s$ lifts, uniquely, to a map on process terms, $\widehat{s} :
\Proc \rightarrow \Proc$ by the following equations.

\begin{eqnarray}
(0) \psubstp{Q}{P}         & = &    0 \nonumber\\
(R \juxtap S) \psubstp{Q}{P}
		& = &    
		(R)\psubstp{Q}{P} \juxtap (S) \psubstp{Q}{P} \nonumber\\
(x \id{(} y\id{)}\concat R) \psubstp{Q}{P}    
		& = &    
		(x)\substp{Q}{P} \id{(}z\id{)}\concat( (R \psubstn{z}{y}) \psubstp{Q}{P} ) \nonumber\\
%(x\id{[}y\id{]}) \psubstp{Q}{P}
%		& = &    
%		(x)\substp{Q}{P} \id{[}(y)\substp{Q}{P} \id{]} \\
(\lift{x}{R}) \psubstp{Q}{P}  
 		& = &
 		\lift{(x)\substp{Q}{P}}{ R \psubstp{Q}{P} } \nonumber\\
(\dropn{x})  \psubstp{Q}{P}       
		& = & 
		\left\{ 
			\begin{array}{ccc} 
				\dropn{\quotep{Q}} & & x \nameeq \quotep{P} \\
                              	\dropn{x} & & otherwise \\
			\end{array}
		\right. \nonumber
\end{eqnarray}
 

where

\begin{eqnarray}
(x)\id{\{} \lpquote Q \rpquote / \lpquote P \rpquote \id{\}}            = 
		\left\{ 
			\begin{array}{ccc}
				\lpquote Q \rpquote & & x \nameeq \lpquote P \rpquote \\
                                x & & otherwise \\
			\end{array}
		\right. \nonumber
\end{eqnarray}

and $z$ is chosen distinct from $\quotep{P}$, $\quotep{Q}$, the free
names in $Q$, and all the names in $R$. Our $\alpha$-equivalence will
be built in the standard way from this substitution.

But, given these mutual recursions, the question is whether the calculation
of $\nameeq$ (respectively, $\scong$, $\alphaeq$) terminates. To
answer this question it suffices to formalize our intuitions regarding
level of quotes, or quote depth, $\#(x)$, of a name $x$ as
follows.

\begin{eqnarray}
	\#(\quotep{P}) & = & 1 + \#(P) \nonumber\\
    \#(P) & = & \left\{
			   \begin{array}{ccc}
				 max\{ \#(x) : x \in \names{P} \} & & \names{P} \neq \emptyset \\
				 0 & & otherwise \\
			   \end{array}
			\right. \nonumber
\end{eqnarray}

The grammar ensures that $\#(\quotep{P})$ is bounded. Then the
termination of $\nameeq$ (respectively, $\scong$, $\alphaeq$) is an
easy induction on quote depth.

\subsection{ Dynamic quote: an example }

Anticipating something of what's to come, consider applying the
substitution, $\widehat{\id{\{}u / z \id{\}}}$, to the following pair
of processes, $\lift{w}{y \id{[}z\id{]}}$ and $w\id{[} \lpquote
y\id{[}z\id{]} \rpquote \id{]}$.

\begin{eqnarray}
	\lift{w}{y \id{[}z\id{]}}\widehat{\id{\{}u / z \id{\}}}
		& = &
		\lift{w}{y \id{[}u\id{]}} \nonumber\\
	w\id{[} \lpquote y\id{[}z\id{]} \rpquote \id{]} \widehat{ \id{\{}u / z \id{\}} }
		& = &
		w\id{[} \lpquote y\id{[}z\id{]} \rpquote \id{]} \nonumber
\end{eqnarray}

Because the body of the process between quotes is impervious to
substitution, we get radically different answers. In fact, by
examining the first process in an input context, e.g. $x \id{(} z
\id{)}\concat \lift{w}{y
\id{[}z\id{]}}$, we see that the process under the lift operator may
be shaped by prefixed inputs binding a name inside it. In this sense,
the lift operator will be seen as a way to dynamically construct
processes before reifying them as names.

\subsection{Semantic substitution}

The substitution used in $\alpha$-equivalence is really only a device
to formally recognize that binding occurrences do not depend on the
specific names. It is not the engine of computation. The proposal here
is that while synchronization is the driver of that engine, the real
engine of computation is a semantic notion of substitution that
recognizes that a dropped name is a request to run a process. Which
process? Why the one whose code has been bound to the name being
dropped. Formally, this amounts to a notion of substitution that
differs from syntactic substitution in its application to a dropped
name.

\begin{eqnarray}
(\dropn{x})  \psubstp{Q}{P}       
		& = & 
		\left\{ 
			\begin{array}{ccc} 
				Q & & x \nameeq \quotep{P} \\
                              	\dropn{x} & & otherwise \\
			\end{array}
		\right. \nonumber
\end{eqnarray}

In the remainder of the paper we will refer to semantic and syntactic
substitutions simply as substitutions and rely on context to
distinguish which is meant. Similarly, we will abuse notation and
write $\substn{y}{x}$ for $\psubstn{y}{x}$.

Finally equipped with these standard features we can present the
dynamics of the calculus.

\subsection{Operational Semantics}
The reduction rules for {\rhoc}  are

\infrule[Comm]
{ {x}_{0} \nameeq {x}_{1} }
{{\lift{x_{0}}{Q} \juxtap { x_{1} \id{(}{y} \id{)} \concat {P}}}
\red {P}\id{\{}\quotep{Q} \id{/} {y} \id{\}}}

In addition, we have the following context rules:

\infrule[Par]{{P} \red {P}'}{{{P} \juxtap {Q}} \red {{P}' \juxtap {Q}}}

\infrule[Equiv]{{{P} \scong {P}'} \andalso {{P}' \red {Q}'} \andalso {{Q}' \scong {Q}}}{{P} \red {Q}}

The context rules are entirely standard and we do not say much about
them, here. The communication rule does what was promised, namely make
it possible for agents to synchronize and communicate processes
packaged as names. For example, using the comm rule and name
equivalence we can now justify our syntactic sugar for output.

\begin{eqnarray}
	& {x}\id{[}{z}\id{]} \juxtap x \id{(}y\id{)} \concat P & \nonumber\\
	= 
	& \lift{x}{\dropn{z}} \juxtap x \id{(}y\id{)} \concat P & \nonumber\\
	\red 
	& P \substn{\quotep{\dropn{z}}}{y} & \nonumber\\
	\scong & P \substn{z}{y} & \nonumber
\end{eqnarray}

But, it also provides a scheme that identifies the role of name
equality in synchronization. There are other relationships between
names with structure that could also mediate
synchronization. Consider, for example, a calculus identical to the
one presented above, but with an alternative rule governing
communication.

\infrule[Comm-annihilation]
{ \forall R . [ P_{channel} \juxtap Q_{channel} \red^* R ] \Rightarrow R \red^* 0 }
{{\lift{\quotep{Q_{channel}}}{Q} \juxtap { {\quotep{P_{channel}}} \id{(}{y} \id{)} \concat {P}}}
\red {P}\id{\{}\quotep{Q} \id{/} {y} \id{\}}}

Intuitively, it says that the codes of a pair of processes,
$P_{channel}$, $Q_{channel}$, stand in channel/co-channel relation
just when the composition of the processes always eventually reduces
to $0$, that is, when the processes annihilate one another.  This rule
is well-founded, for observe that because $0 \scong 0 \juxtap 0$, $0
\juxtap 0 \red^* 0$. Thus, $\quotep{0}$ serves as its own
co-channel. Analogous to our generation of names from $0$, with one
such channel/co-channel pair, we can find many such pairs. What we
wish to point out about this rule is that we can see precisely an
account of the calculation of the channel/co-channel relationship as
deriving from the theory of interaction. We do not know if the
computation of name equality has a similar presentation, driving home
the potential difference of those two roles in calculi of interaction.

We mention, as a brief aside, that there is no reason why $0$ is
special in the scheme above. We posit a family of calculi, indexed by
a set of processes $\{ S_{\alpha} \}$, and differing only in their
communication rule each of which conforms to the scheme below.

\infrule[Comm-annihilation-S]
{ \forall R . [ P_{channel} \juxtap Q_{channel} \red^* R ] \Rightarrow R \red^* R' \scong S_{\alpha} }
{{\lift{\quotep{Q_{channel}}}{Q} \juxtap { {\quotep{P_{channel}}} \id{(}{y} \id{)} \concat {P}}}
\red {P}\id{\{}\quotep{Q} \id{/} {y} \id{\}}}

We explore this family of calculi in a forthcoming paper. For the rest
of this paper, however, we restrict our attention to the calculus with
the less exotic communication rule, using $\red$ for reduction
according to that system and $\wred$ for $\red^*$.

\section{Replication}

As mentioned before, it is known that replication (and hence
recursion) can be implemented in a higher-order process algebra
\cite{SangiorgiWalker}. As our first example of calculation with the
machinery thus far presented we give the construction explicitly in
the {\rhoc}.

\begin{eqnarray}
	D(x) & \triangleq & \prefix{x}{y}{(\binpar{\outputp{x}{y}}{\dropn{y}})} \nonumber\\
	\bangp{P}(x) & \triangleq & \binpar{\lift{x}{\binpar{D(x)}{P}}}{D(x)} \nonumber
\end{eqnarray}

\begin{eqnarray}
	\bangp{P}(x) & & \nonumber\\
	=
	& \lift{x}{(\prefix{x}{y}{(\outputp{x}{y} \juxtap \dropn{y})) \juxtap P}} 
	      \juxtap \prefix{x}{y}{(\outputp{x}{y} \juxtap \dropn{y})} & \nonumber\\
	\red
	& (\outputp{x}{y} \juxtap \dropn{y})\substn{\quotep{(\prefix{x}{y}{(\dropn{y} \juxtap \outputp{x}{y})) \juxtap P}}}{y} & \nonumber\\
	=
	& \outputp{x}{\quotep{(\prefix{x}{y}{(\outputp{x}{y} \juxtap \dropn{y})) \juxtap P}}}
	  \juxtap {(\prefix{x}{y}{(\outputp{x}{y} \juxtap \dropn{y})) \juxtap P}} & \nonumber\\
	\red
	& \ldots & \nonumber\\
	\red^*
	& P \juxtap P \juxtap \ldots & \nonumber
\end{eqnarray}

Of course, this encoding, as an implementation, runs away, unfolding
$\bangp{P}$ eagerly. As it is instructive to construct a lazier -- and
more implementable -- replication operator, restricted to
input-guarded processes we recommend this exercise to the reader
interested in gaining further inside into the mechanics of the
calculus.

\section{Bisimulation}

Having taken the notion of restriction out of the language, we
carefully place it back into the notion of observation, and hence into
the notion of program equality, i.e. bisimulation. That is, we
parameterize the notion of barbed bisimulation by a set of names over
which we are allowed to set the barbs. The motivation for this choice
is really comparison with other calculi. The set of names of the
{\rhoc} is \textit{global}. It is impossible, in the grammar of
processes, to guard terms from being placed into contexts that can
potentially observe communication. So, we provide a place for
reasoning about such limitations on the scope of observation in the
theory of bisimulation.

\begin{definition}
An \emph{observation relation}, $\downarrow_{\mathcal N}$, over a set
of names, $\mathcal N$, is the smallest relation satisfying the rules
below.

\infrule[Out-barb]{y \in {\mathcal N}, \; x \nameeq y}
		  {\outputp{x}{v} \downarrow_{\mathcal N} x}
\infrule[Par-barb]{\mbox{$P\downarrow_{\mathcal N} x$ or $Q\downarrow_{\mathcal N} x$}}
		  {\binpar{P}{Q} \downarrow_{\mathcal N} x}

We write $P \Downarrow_{\mathcal N} x$ if there is $Q$ such that 
$P \wred Q$ and $Q \downarrow_{\mathcal N} x$.
\end{definition}

Notice that $\prefix{x}{y}{P}$ has no barb.  Indeed, in {\rhoc} as well
as other asynchronous calculi, an observer has no direct means to
detect if a message sent has been received or not.

\begin{definition}
%\label{def.bbisim}
An  ${\mathcal N}$-\emph{barbed bisimulation} over a set of names, ${\mathcal N}$, is a symmetric binary relation 
${\mathcal S}_{\mathcal N}$ between agents such that $P\rel{S}_{\mathcal N}Q$ implies:
\begin{enumerate}
\item If $P \red P'$ then $Q \wred Q'$ and $P'\rel{S}_{\mathcal N} Q'$.
\item If $P\downarrow_{\mathcal N} x$, then $Q\Downarrow_{\mathcal N} x$.
\end{enumerate}
$P$ is ${\mathcal N}$-barbed bisimilar to $Q$, written
$P \wbbisim_{\mathcal N} Q$, if $P \rel{S}_{\mathcal N} Q$ for some ${\mathcal N}$-barbed bisimulation ${\mathcal S}_{\mathcal N}$.
\end{definition}

\section{Logic}
Namespace logic resides in the subfamily of Hennessy-Milner logics
discovered by Caires and Cardelli and known as spatial logics
\cite{DBLP:journals/tcs/CairesC04}. Thus, as is seen below, in
addition to the action modalities, we also find formulae for
\emph{separation}, corresponding, at the logical level, to the
structural content of the parallel operator at the level of the
calculus. Likewise, we have quantification over names. 

In this connection, however, we find an interesting difference between
spatial logics investigated heretofore and this one. As in the
calculus, we find no need for an operator corresponding to the $\nu$
construction. However, revelation in spatial logic, is a structural
notion \cite{DBLP:journals/tcs/CairesC04}. It detects the
\emph{declaration} of a new name. No such information is available in
the reflective calculus or in namespace logic. The calculus and the
logic can arrange that names are used in a manner consistent with
their being declared as new in the {\pic}, but it cannot detect the
declaration itself. Seen from this perspective, revelation is a
somewhat remarkable observation, as it seems to be about detecting the
programmer's intent.

\begin{grammar}
\mbox{reflective logic}	& {\phi, \psi}	& \bc	& \ptrue & \mbox{verity} \\
				&					& \bm	& \pzero & \mbox{nullity} \\
				&					& \bm	& \neg \phi & \mbox{negation} \\
				&					& \bm	& \phi \& \psi & \mbox{conjunction} \\
				&					& \bm	& \phi \juxtap \psi & \mbox{separation} \\
				&					& \bm	& \pdropf{b} & \mbox{descent} \\
				&					& \bm	& \plift{a}{\phi} & \mbox{elevation} \\
				&					& \bm	& \pprefix{a}{b}{\phi} & \mbox{activity} \\
                                &					& \bm	& \pgfp{X}{\phi} & \mbox{greatest fix point} \\
                                &					& \bm	& \pquant{n}{\psi}{\phi} & \mbox{quantification} \\
				& {a}  		& \bc	& \quotep{\phi} & \mbox{indication} \\
				&					& \bm	& b & \mbox{...} \\
				& {b}  		& \bc	& \quotep{P} & \mbox{nomination} \\
                                &					& \bm	& n & \mbox{...} \\
\end{grammar}

We let $\PFormula$ denote the set of formulae generated by the
$\phi$-production, $\QFormula$ denote the set of formulae generated by
the $a$-production and $\PropVar$ denote the set of propositional
variables used in the $\textsf{rec}$ production.

% The satisfaction relation, $\models \subseteq \Proc \times \Formula$, between processes and formulae is given by

% \begin{eqnarray}
% 	P & \models & \ptrue \nonumber \\ 
%     P & \models & \pzero \riff P \scong \pzero \nonumber \\ 
%     P & \models & \neg \phi \riff P \not\models \phi \nonumber\\
%     P & \models & \phi \& \psi \riff P \models \phi \; \& P \; \models \psi \nonumber\\
%     P & \models & \binpar{\phi}{\psi} \riff \exists P_0, P_1.P \scong \binpar{P_0}{P_1}
%       \; \& \; P_0 \models \phi \; \& \;  P_1 \models \psi \nonumber\\
%     P & \models & \pdropf{b} \riff \exists Q, P'.P \scong \binpar{Q}{\dropn{x}}
% 	    \; \& \; x \models b \nonumber\\	
% 	P & \models & \plift{a}{\phi} \riff \exists Q, P'.P \scong \binpar{Q}{\lift{x}{P'}} 
% 		\; \& \; x \models a 
% 		\; \& \; P' \models \phi \nonumber\\
% 	P & \models & \pprefix{a}{b}{\phi} \riff \exists Q, P'.P \scong \binpar{Q}{\prefix{x}{y}{P'}} \nonumber\\
% 	  & & x \models a \nonumber\\
% 	  & & \forall c . \exists z . {P'}\substn{z}{y} \models {\phi}\substn{c}{b} \nonumber\\
%     \quotep{P} & \models & \quotep{\phi} \riff P \models \phi \nonumber\\
%     \quotep{P} & \models & \quotep{Q} \riff \quotep{P} \nameeq \quotep{Q} \nonumber
% \end{eqnarray}

Inspired by Caires' presentation of spatial logic
\cite{DBLP:conf/fossacs/Caires04}, we give the semantics in terms of
sets of processes (and names). We need the notion of a valuation $v :
\PropVar \to \wp(\Proc)$, and use the notation $v\substn{\mathcal{S}}{X}$ to mean 

\begin{eqnarray}
  v\substn{\mathcal{S}}{X}(Y) & = &
  \left\{ \begin{array}{ccc}
      S & & Y = X \\
      v(Y) & & otherwise \\
    \end{array}
  \right.\nonumber
\end{eqnarray}

The meaning of formulae is given in terms of two mutually recursive functions,

\begin{eqnarray}
\pmeaningof{ - }( - ) : \PFormula \times [\PropVar \to \wp(\Proc)] \to \wp(\Proc) \nonumber\\
\nmeaningof{ - }( - ) : \QFormula \times [\PropVar \to \wp(\Proc)] \to \wp(\QProc) \nonumber
\end{eqnarray}

taking a formula of the appropriate type and a valuation, and
returning a set of processes or a set of names, respectively.

\begin{eqnarray}
  \pmeaningof{\ptrue}(v) & = & \Proc \nonumber \\ 
  \pmeaningof{\pzero}(v) & = & \{ P : P \scong \pzero \} \nonumber \\ 
  \pmeaningof{\neg \phi}(v) & = & \Proc / \pmeaningof{\phi}(v) \nonumber\\
  \pmeaningof{\phi \& \psi}(v) & = & \pmeaningof{\phi}(v) \cap \pmeaningof{\psi}(v) \nonumber\\
  \pmeaningof{\binpar{\phi}{\psi}}(v) & = &
  \{ P : \exists P_0, P_1.P \scong \binpar{P_0}{P_1}, \; P_0 \in \pmeaningof{\phi}(v), \;  P_1 \in \pmeaningof{\psi}(v) \} \nonumber\\
  \pmeaningof{\pdropf{b}}(v) & = & \{ P : \exists Q, P'.P \scong \binpar{Q}{\dropn{x}}, \; x \in \nmeaningof{b}(v) \} \nonumber\\	
  \pmeaningof{\plift{a}{\phi}}(v) & = & \{ P : \exists Q, P'.P \scong \binpar{Q}{\lift{x}{P'}},
                                           \; x \in \nmeaningof{a}(v), 
                                           \; P' \in \pmeaningof{\phi}(v) \} \nonumber\\
  \pmeaningof{\pprefix{a}{b}{\phi}}(v) & = & \{ P : \exists Q, P'.P \scong \binpar{Q}{\prefix{x}{y}{P'}}, x \in \nmeaningof{a}(v), \nonumber\\
                                   &   &            \; \; \; \forall c . \exists z . {P'}\substn{z}{y} \in \pmeaningof{{\phi}\substn{c}{b}}(v) \} \nonumber\\
  \pmeaningof{\pgfp{X}{\phi}}(v) & = & \cup \{ \mathcal{S} \subseteq \Proc : \mathcal{S} \subseteq \pmeaningof{\phi}(v\substn{\mathcal{S}}{X})\} \nonumber\\
  \pmeaningof{\pquant{n}{\psi}{\phi}}(v) & = & \cap_{x \in \nmeaningof{\quotep{\psi}}(v)} \pmeaningof{{\phi}\substn{x}{n}}(v) \nonumber\\
  \nmeaningof{\quotep{\phi}}(v) & = & \{ x : x \nameeq \quotep{P}, P \in \pmeaningof{\phi}(v) \} \nonumber\\
  \nmeaningof{\quotep{P}}(v) & = & \{ x : x \nameeq  \quotep{P} \} \nonumber
\end{eqnarray}

We say $P$ witnesses $\phi$ (resp., $x$ witnesses $\quotep{\phi}$),
written $P \models \phi$ (resp., $x \models \quotep{\phi}$) just when
$\forall v . P \in \meaningof{\phi}(v)$ (resp., $\forall v . x \in \meaningof{\quotep{\phi}}(v)$).

\begin{theorem}[Equivalence]
	$P \wbbisim Q \riff \forall \phi . P \models \phi \riff Q \models \phi .$
\end{theorem}

The proof employs an adaptation of the standard strategy. As noted in
the introduction, this theorem means that there is no algorithm
guaranteeing that a check for the witness relation will terminate.

\subsubsection{Syntactic sugar }

In the examples below, we freely employ the usual DeMorgan-based
syntactic sugar. For example,

\begin{eqnarray}
	\phi \Rightarrow \psi & \triangleq & \neg ( \phi \& \neg \psi ) \nonumber\\
	\phi \vee \psi & \triangleq & \neg ( \neg \phi \& \neg \psi ) \nonumber
\end{eqnarray}

Also, when quantification ranges over all of $\Proc$, as in
$\pquant{n}{\quotep{\ptrue}}{\phi}$, we omit the typing for the
quantification variable, writing $\pquantuntyped{n}{\phi}$.

\subsection{Examples}

\subsubsection{Controlling access to namespaces}

Suppose that $\quotep{\phi}$ describes some namespace, i.e. some
collection of names. We can insist that a process restrict its next
input to names in that namespace by insisting that it witness the formula

\begin{eqnarray}
  \pprefix{\quotep{\phi}}{b}{\ptrue} \& \neg \pprefix{\quotep{\neg \phi}}{b}{\ptrue} \nonumber
\end{eqnarray}

which simply says the the process is currently able to take input from
a name in the namespace $\quotep{\phi}$ and is not capable of input on
any name not in that namespace. In a similar manner, we can limit a
server to serving only inputs in $\quotep{\phi}$ throughout the
lifetime of its behavior \footnote{Of course, this formula also says
  the server never goes down, either -- or at least is always willing
  to take such input...;-)}

\begin{eqnarray}
  \pgfp{X}{\pprefix{\quotep{\phi}}{b}{X} \& \neg \pprefix{\quotep{\neg \phi}}{b}{\ptrue}} \nonumber
\end{eqnarray} 

This formula is reminiscent of the functionality of a firewall, except
that it is a \emph{static} check. A process witnessing this formula
will behave as though it were behind a firewall admitting only access
to the ports in $\quotep{\phi}$ without the need for the additional
overhead of the watchdog machinery.

\subsubsection{Validating the structure of data}

Of course, the previous example might make one wonder what a useful
namespace looks like. The relevance of this question is further
amplified when we observe that processes pass names as messages as
well as use them to govern synchronization. The next example,
therefore, considers a space of names that might be seen as
well-suited to play the role of data, for their structure loosely
mimics the structure of the infoset model \cite{W3CInfoset} of
\texttt{XML} (sans schema).

\begin{eqnarray}
  \phi_{info} & = &
  \quotep{\pgfp{X}
    {(\pquantuntyped{m}
      {\plift
        {m}
        {\pquantuntyped
          {n}
          {\pzero
            \vee \plift{n}{X}
            \vee \pgfp{Y}{(\pquantuntyped{n'}{\pprefix{n'}{b}{(X \vee Y)}})}
            \vee (\binpar{X}{X})
          }}})}}\nonumber
\end{eqnarray} 

The formula is essentially a recursive disjunction selecting names
that are first of all rooted with an enclosing lift operation --
reminiscent of the way an \texttt{XML} document has a single enclosing
root; and then are either

\begin{itemize}
\item the empty `document'; or
\item an `element'; or
\item a sequence of documents each `located' at an input action; or
\item an unordered group.
\end{itemize}

Notice that it is possible to parameterize this namespace on names for
rooting `documents' or `elements'. Currently, these are typed as
coming from the whole namespace, ${\quotep{\ptrue}}$, but they could
come from any subspace.

Moreover, the formula is itself a template for the interpretation of
schema specifications \cite{W3CXSD}. If we boil \texttt{XSD} schema
down to its essential type constructors, we have a recursive
specification in which a schema is a

\begin{itemize}
\item a sequence, or
\item a choice, or
\item a group, or
\item a recursion, in which a type name is bound to a schema definition
\end{itemize}

of element-tagged schema or schema references, with the recursive
specification bottoming out at the simple and builtin
types. Abstractly, then essential structures of \texttt{XSD} schema
are captured by the grammar

\begin{grammar}
\mbox{schema}		        & {S}   	                        & \bc	& \epsilon & \mbox{empty document} \\
				&					& \bm	& ESequence & \mbox{sequence} \\
				&					& \bm	& EChoice & \mbox{choice} \\
				&					& \bm	& EGroup & \mbox{group} \\
                                &					& \bm	& \pgfp{N}{S} & \mbox{recursion} \\
				& {ESequence}   		& \bc	& \epsilon \; \mid \; E,ESequence & \mbox{sequence of elements} \\
                                & {EChoice}     		& \bc	& \epsilon \; \mid \; E+EChoice & \mbox{choice of elements} \\
                                & {EGroup}      		& \bc	& \epsilon \; \mid \; E \juxtap EGroup & \mbox{group of elements} \\
                                & {E}           		& \bc	& tag(N \mid S) & \mbox{element} \\
\end{grammar}

We use $s$ to range over schema, $\sigma$, $\chi$ and $\gamma$ to
range over sequences, choices and groups, respectively.

The encoding below, which for clarity makes liberal -- but obvious --
use of polymorphism and elides the standard machinery for
treating recursion variables, illustrates that we can view this
grammar as essentially providing a high-level language for carving out
namespaces in which the names conform to the schema.

\begin{eqnarray}
  \meaningof{\epsilon} & = & \quotep{\pzero} \nonumber\\
  \meaningof{tag(s), \sigma}
  & = & \quotep{\pquant{n}{\meaningof{tag}}{\pprefix{n}{b}{(\binpar{\meaningof{s}}{\meaningof{\sigma}})}}} \nonumber\\
  \meaningof{tag(s) + \chi}
  & = & \quotep{\pquant{n}{\meaningof{tag}}{(\pprefix{n}{b}{\meaningof{s}}) \vee \meaningof{\chi}}} \nonumber\\
  \meaningof{tag(s) \mid \gamma}
  & = & \quotep{\pquant{n}{\meaningof{tag}}{(\pprefix{n}{b}{\meaningof{s}}) \juxtap \meaningof{\gamma}}} \nonumber\\
\meaningof{\pgfp{N}{s}}
  & = & \quotep{\pgfp{N}{\meaningof{s}}} \nonumber
\end{eqnarray}

We emphasize that the example is not meant to be a complete account of
\texttt{XML} schema. Rather, it is intended to suggest that with the
reflective capabilities the logic gives a fairly intuitive treatment
of names as structured data. The simplicity and intuitiveness of the
treatment is really brought home, however, when employing the
framework analytically. As an example, from a commonsense perspective
it should be the case that any \texttt{XML} document that observes a schema
automatically also corresponds to an infoset. The reader is encouraged
to try her hand at using the framework to establish that if $s$ is a
schema, then

\begin{eqnarray}
  x \models \meaningof{s} \Rightarrow x \models \phi_{info}' \nonumber
\end{eqnarray}

where $\phi_{info}'$ a suitably modified version of $\phi_{info}$.

\section{Conclusions and future work}

We introduced namespace logic, a spatial-style Hennessy-Milner logic
for a reflective asynchronous message-passing calculus built out of a
notion of quote. We introduced some examples highlighting potential
applications to security and data analysis.

We note that this work is situated in the larger context of a growing
investigation into naming and computation. Milner's studies of action
calculi led not only to reflexive action calculi
\cite{DBLP:conf/tacs/Milner97}, but to Power's and Hermida's work on
name-free accounts of action calculi
\cite{DBLP:conf/concur/HermidaP95} as well as Pavlovic's
\cite{PavlovicD:CLNA}.  Somewhat farther afield, but still related, is
Gabbay's theory of freshness \cite{GabbayMJ:picfm} and the nominal
logics \cite{DBLP:conf/lics/GabbayC04}. Very close to the mark,
Carbone and Maffeis observe a tower of expressiveness resulting from
adding very simple structure to names \cite{polysync}. In some sense,
this may be viewed as approaching the phenomena of structured names
`from below'. By making names be processes, this work may be seen as
approaching the same phenomena `from above'. But, both investigations
are really the beginnings of a much longer and deeper investigation of
the relationship between process structure and name structure.

Beyond foundational questions concerning the theory of interaction, or
applications to security and data analysis such an investigation may
be highly warranted in light of the recent connection between
concurrency theory and biology. In particular, despite the interesting
results achieved by researchers in this field, there is a fundamental
difference between the kind of synchronization observed in the {\pic}
and the kind of synchronization observed between molecules at the
bio-molecular level. The difference is that interactions in the latter
case occur at sites with extension and behavior of their own
\cite{Fontana}. An account of these kinds of phenomena may be revealed
in a detailed study of the relationship between the structure of names
and the structure of processes.

\paragraph{Acknowledgments.}
The authors wish to thank Robin Milner for his thoughtful and
stimulating remarks regarding earlier work in this direction, and
Cosimo Laneve for urging us to consider a version of the calculus
without heating rules.

% ------------------------------------------------------------------------
%GATHER{Xbib.bib}   % For Gather Purpose Only
%GATHER{Paper.bbl}  % For Gather Purpose Only
\bibliographystyle{plain}
\bibliography{ex_nihilo_logic}

% ------------------------------------------------------------------------

% ------------------------------------------------------------------------

\end{document}
% ------------------------------------------------------------------------
